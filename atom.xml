<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fei&#39;s Blog</title>
  
  <subtitle>Insist on writing!</subtitle>
  <link href="https://zhangfei614.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhangfei614.github.io/"/>
  <updated>2022-11-16T14:17:13.715Z</updated>
  <id>https://zhangfei614.github.io/</id>
  
  <author>
    <name>Fei Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac装机配置</title>
    <link href="https://zhangfei614.github.io/2022/06/16/mac-setup/"/>
    <id>https://zhangfei614.github.io/2022/06/16/mac-setup/</id>
    <published>2022-06-16T15:21:12.000Z</published>
    <updated>2022-11-16T14:17:13.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zsh相关配置"><a href="#Zsh相关配置" class="headerlink" title="Zsh相关配置"></a>Zsh相关配置</h3><ol start="0"><li>生成ssh-key: ssh-keygen -t ed25519，并运行ssh-agent,ssh-add</li><li>安装iterm2, vscode, brew, oh-my-zsh, tmux, autojump<ul><li>export TERM&#x3D;xterm-256color,HOMEBREW_NO_AUTO_UPDATE&#x3D;1</li></ul></li><li>安装znap，znap-plugins(zsh-completions, zsh-autosuggestions)<ul><li>参考链接：<a href="https://pablo.tools/blog/computers/znap-zsh-plugin-manager/">The Znap ZSH plugin-manager</a></li></ul></li><li>更新<a href="https://gist.github.com/zhangfei614/d257314e08a49f144cb002b3e6c673aa">.zshrc</a></li></ol><h3 id="Go-k8s-Docker-相关安装"><a href="#Go-k8s-Docker-相关安装" class="headerlink" title="Go, k8s, Docker 相关安装"></a>Go, k8s, Docker 相关安装</h3><ol><li>brew install go, kubectl, minikube</li><li>brew install –casks docker</li><li>set envs in <a href="https://gist.github.com/zhangfei614/d257314e08a49f144cb002b3e6c673aa">.zshrc</a></li></ol><h3 id="其它工具安装"><a href="#其它工具安装" class="headerlink" title="其它工具安装"></a>其它工具安装</h3><ol><li>Clipy， 管理复制粘贴。</li><li>Magent，管理窗口。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Zsh相关配置&quot;&gt;&lt;a href=&quot;#Zsh相关配置&quot; class=&quot;headerlink&quot; title=&quot;Zsh相关配置&quot;&gt;&lt;/a&gt;Zsh相关配置&lt;/h3&gt;&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;生成ssh-key: ssh-keygen -t ed25519，并</summary>
      
    
    
    
    <category term="Tools" scheme="https://zhangfei614.github.io/categories/Tools/"/>
    
    
    <category term="Mac, Tools" scheme="https://zhangfei614.github.io/tags/Mac-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Nvim配置趟坑</title>
    <link href="https://zhangfei614.github.io/2022/06/14/nvim-config/"/>
    <id>https://zhangfei614.github.io/2022/06/14/nvim-config/</id>
    <published>2022-06-14T14:04:16.000Z</published>
    <updated>2022-11-16T14:23:48.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nvim配置流水"><a href="#nvim配置流水" class="headerlink" title="nvim配置流水"></a>nvim配置流水</h3><ol><li>参考<a href="https://juejin.cn/book/7051157342770954277/section/7051157342846451748">learn-neovim-lua</a>。</li><li>快捷键部分，因为Mac上没有Alt，在iterm2中设置左Option-&gt;Esc+。<br><img src="https://i.imgur.com/nGuW7IE.png" alt="图 2"></li><li>将所有plugin注释掉，按需开启；将plugin拉取git仓库的方式从https改为git-ssh的方式；注释掉更改plugins.lura，自动更新代码。</li><li>安装nvim-tree插件： 注意将回车设置成打开文件；安装nerd-font显示各类图标；打开显示dotfile。</li><li>安装bufferline和lualine组件：多标签页打开。</li><li>安装telescopre组件：先brew安装reggrep,fd。</li><li>安装dashboard组件：自定义开始界面和功能。</li><li>安装treesiter组件：语法高亮，语法树选中，代码折叠等功能。</li><li>安装LSP等功能：同时安装npm等工具；</li><li>其他工具：<ul><li>indent-blankline:在上下文锻炼段落前加上指示。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># intsall </span></span><br><span class="line">brew install neovim</span><br><span class="line"><span class="comment"># copy config from learn-neovim-lua</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:zhangfei614/nvim-lua-guide.git ~/.config/nvim</span><br><span class="line"></span><br><span class="line"><span class="comment"># install nd font</span></span><br><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line">brew install --cask font-hack-nerd-font</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/book/7051157342770954277/section/7058595345445421095">Neovim 配置实战：从0到1打造自己的IDE</a></li><li><a href="https://github.com/zhangfei614/nvim-lua-guide">ZhangFei’s Nvim</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;nvim配置流水&quot;&gt;&lt;a href=&quot;#nvim配置流水&quot; class=&quot;headerlink&quot; title=&quot;nvim配置流水&quot;&gt;&lt;/a&gt;nvim配置流水&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参考&lt;a href=&quot;https://juejin.cn/book/705115</summary>
      
    
    
    
    <category term="Tools" scheme="https://zhangfei614.github.io/categories/Tools/"/>
    
    
    <category term="nvim, tool, config" scheme="https://zhangfei614.github.io/tags/nvim-tool-config/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的MLOps</title>
    <link href="https://zhangfei614.github.io/2022/05/20/mlops/"/>
    <id>https://zhangfei614.github.io/2022/05/20/mlops/</id>
    <published>2022-05-19T18:52:34.000Z</published>
    <updated>2022-06-13T15:57:58.859Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%BA%8F">序</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">问题背景</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFmlops">什么是MLOps？</a><ul><li><a href="#%E5%85%83%E7%B4%A0%E8%A7%92%E8%89%B2%E6%B5%81%E7%A8%8B">元素、角色、流程</a></li><li><a href="#%E5%90%8D%E8%AF%8D%E5%AF%B9%E6%AF%94">名词对比</a></li></ul></li><li><a href="#%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0">开源实现</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3">部署相关</a><ul><li><a href="#core%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AF%B9%E6%AF%94">Core工具链对比</a></li></ul></li><li><a href="#%E6%97%B7%E8%A7%86%E7%9A%84mlops">旷视的MLOps？</a><ul><li><a href="#%E5%A4%8D%E6%9D%82%E8%83%8C%E6%99%AF">复杂背景</a></li><li><a href="#ipu%E5%9C%A8%E5%81%9A%E5%95%A5">IPU在做啥？</a></li><li><a href="#%E5%85%A8%E6%B5%81%E7%A8%8B">全流程？</a></li></ul></li><li><a href="#mlops-sig">MLOps-Sig</a></li><li><a href="#%E7%BB%88">终</a></li></ul><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>MLOps这个概念最近比较流行，晨光也发了一些<a href="https://ipu-discourse.megvii-inc.com/t/topic/1549">Link</a>给大家参考。之前在做<a href="https://ipu-discourse.megvii-inc.com/t/topic/1579/3">Saver</a>和介绍<a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=34896780&preview=/34896780/299343248/Model%20Serving.pptx">ModelServing</a>的过程中，查过一些资料，可以整理一下供大家参考。MLOps涵盖的概念比较多，我也是不求甚解，有兴趣可以多了解一些，对于IPU可以在公司内MLOps上做什么也可以多讨论。</p><span id="more"></span><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><img src="/images/2022-05-20-mlops/img-2022-05-23-01-14-55.png"><br>大部分介绍MLOps的文章都会引用这张图，出自Google的一篇论文：<a href="https://papers.nips.cc/paper/2015/file/86df7dcfd896fcaf2674f757a2463eba-Paper.pdf">Hidden Technical Debt in Machine Learning Systems</a><br>核心内容：</p><ul><li>利用机器学习解决问题的完整系统，关于模型训练的代码其实只占很少一部分。</li><li>为了系统中各个模块合作，各类“胶水代码”会有很多反模式设计，很难维护，留下很多隐藏的“技术债”。</li></ul><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/111694069"> Hidden Technical Debt in Machine Learning Systems 阅读笔记</a></li><li><a href="https://ml-ops.org/content/motivation"> Why you Might Want to use Machine Learning </a></li></ul><h2 id="什么是MLOps？"><a href="#什么是MLOps？" class="headerlink" title="什么是MLOps？"></a>什么是MLOps？</h2><p><img src="/images/2022-05-20-mlops/img-2022-05-23-01-15-38.png"><br>from <em><a href="https://ml-ops.org/content/mlops-principles"> MLOps Principles</a></em></p><blockquote><p>顾名思义，MLOps就是机器学习时代的DevOps。它的主要作用就是连接模型构建团队和业务，运维团队，建立起一个标准化的模型开发，部署与运维流程，使得企业组织能更好的利用机器学习的能力来促进业务增长。 from  <a href="https://zhuanlan.zhihu.com/p/357897337"> 从小作坊到智能中枢: MLOps简介</a></p></blockquote><h3 id="元素、角色、流程"><a href="#元素、角色、流程" class="headerlink" title="元素、角色、流程"></a>元素、角色、流程</h3><p>MLOps与传统Devops最大不同是管理的最基本要素从Code，扩充到了Data&amp;Model&amp;Code，而这三者之间的相互流转一般会牵扯到不同角色。如何利用自动化工具打破角色、组织之前的边界，可持续的交付机器学习能力到用户侧是MLOps要解决的问题。</p><p><strong>元素：</strong><br><img src="/images/2022-05-20-mlops/img-2022-05-23-01-15-48.png"><br><strong>角色：</strong><br><img src="/images/2022-05-20-mlops/img-2022-05-23-01-15-56.png"><br><strong>流程</strong><br><img src="/images/2022-05-20-mlops/img-2022-05-23-01-16-04.png"><br>from <em><a href="https://martinfowler.com/articles/cd4ml.html"> Continuous Delivery for Machine Learning</a></em></p><h3 id="名词对比"><a href="#名词对比" class="headerlink" title="名词对比"></a>名词对比</h3><p><img src="/images/2022-05-20-mlops/img-2022-05-23-01-16-20.png"></p><blockquote><p><strong>DevOps 更快地交付软件</strong><br>一系列旨在消除开发和运维团队之间障碍的实践，以便更快地构建和部署软件。它通常会被工程团队所采用，包括 DevOps 工程师、基础设施工程师、软件工程师、站点可靠性工程师和数据工程师。<br><strong>DataOps 更快地交付数据</strong><br>一系列旨在提高数据分析质量并缩短分析周期的实践。DataOps 的主要任务包括数据标记、数据测试、数据管道编排、数据版本控制和数据监控。分析和大数据团队是 DataOps 的主要操作者，但是任何生成和使用数据的人都应该采用良好的 DataOps 实践。这包括数据分析师、BI 分析师、数据科学家、数据工程师，有时还包括软件工程师。<br><strong>MLOps 更快地交付机器学习模型</strong><br>一系列设计、构建和管理可重现、可测试和可持续的基于 ML 的软件实践。对于大数据 &#x2F; 机器学习团队，MLOps 包含了大多数 DataOps 的任务以及其他特定于 ML 的任务，例如模型版本控制、测试、验证和监控。<br><strong>AIOps 利用 AI 的功能增强了 DevOps 工具</strong><br>有时人们错误地将 MLOps 称为 AIOps，但它们是完全不同的。以下说明来自 Gartner（高德纳，美国咨询公司）：<br>AIOps 平台利用大数据、现代机器学习以及其他先进的分析技术，直接或间接地增强 IT 运维（监控、自动化和服务台），具有前瞻性、个性化以及动态的洞察力。<br>因此，AIOps 通常是利用 AI 技术来增强服务产品的 DevOps 工具。AWS Cloud Watch 提供的报警和异常检测是 AIOps 的一个很好的例子。</p></blockquote><p><em>from <a href="https://www.infoq.cn/article/Wqi0WH8ejldPUWl2dLbs"> What the Ops are you talking about?</a></em></p><p><strong>MLOps概念参考链接</strong></p><ul><li><a href="https://ml-ops.org/">https://ml-ops.org/</a></li><li><a href="https://en.wikipedia.org/wiki/MLOps">https://en.wikipedia.org/wiki/MLOps</a></li><li><a href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning?hl=zh-cn"> MLOps：机器学习中的持续交付和自动化流水线</a><ul><li>Google将MLOps流水线按照自动化程度分了3个Level，可以参考。</li></ul></li><li><a href="https://azure.microsoft.com/en-us/services/machine-learning/mlops/#resources">Machine learning operations (MLOps) Resource Center from Azure</a></li><li><a href="https://www.bilibili.com/video/BV1WB4y1P7Hw"> 吴恩达：从以模型为中心到以数据为中心的AI</a><ul><li>吴恩达同时也有一门关于<a href="https://www.bilibili.com/video/BV1ji4y197pv?spm_id_from=333.999.0.0">MLOps的课程</a>，讲解如何E2E训练、部署、监控模型。</li></ul></li></ul><h2 id="开源实现"><a href="#开源实现" class="headerlink" title="开源实现"></a>开源实现</h2><p>MLOps这个概念说实在的，其实是一个大杂烩，涵盖机器学习全链路的所有工具链。但一般来说，讨论MLOps，可能有主要这两个方向：</p><ul><li>规范流：和DevOps类似，MLOps并不具体指某个单一的系统，而是强调各组织之间合作的规范性。这一部分比较虚，可以参考MLOps设计的一些<a href="https://ml-ops.org/content/mlops-principles">基本原则</a>和<a href="https://ml-ops.org/content/mlops-stack-canvas">技术选型指导</a>。</li><li>平台流：在MLOps这个方向，已经有很多开源或者创业团队在做，很多实现了一个统一的平台入口，进行数据、模型、部署的管理。</li></ul><p>在这里简单分享几个MLOps平台案例：<br><strong><a href="https://www.kubeflow.org/docs/started/architecture/">Kubeflow</a></strong></p><blockquote><p>The Kubeflow project is dedicated to making deployments of machine learning (ML) workflows on Kubernetes simple, portable and scalable. Our goal is not to recreate other services, but to provide a straightforward way to deploy best-of-breed open-source systems for ML to diverse infrastructures. Anywhere you are running Kubernetes, you should be able to run Kubeflow.</p></blockquote><ul><li>以Google为首，目前star数最多，影响比较大的MLOps的云原生平台。</li><li>在k8s云原生基础上，集成必要的开源组件，来管理模型开发的流程。</li><li>以Operator为核心，来管理不同训练架构在k8s上执行的训练Job。</li></ul><p><strong><a href="https://github.com/allegroai/clearml">ClearML</a></strong></p><blockquote><p>ClearML is a ML&#x2F;DL development and production suite, it contains FOUR main modules:</p><ul><li><a href="https://github.com/allegroai/clearml#clearml-experiment-manager">Experiment Manager</a> - Automagical experiment tracking, environments and results</li><li><a href="https://github.com/allegroai/clearml-agent">MLOps</a> - Orchestration, Automation &amp; Pipelines solution for ML&#x2F;DL jobs (K8s &#x2F; Cloud &#x2F; bare-metal)</li><li><a href="https://github.com/allegroai/clearml/blob/master/docs/datasets.md">Data-Management</a> - Fully differentiable data management &amp; version control solution on top of object-storage (S3 &#x2F; GS &#x2F; Azure &#x2F; NAS)</li><li><strong>NEW</strong> 🔥 <a href="https://github.com/allegroai/clearml-serving">Model-Serving</a> 🎉 - <em>cloud-ready</em> Scalable model serving solution!<br>✨ <strong>Deploy new model endpoints in under 5 minutes</strong> ✨<br>💪 includes optimized GPU serving support backed by Nvidia-Triton 🦾<br>📊 <strong>with out-of-the-box Model Monitoring</strong> 😱</li></ul></blockquote><ul><li>看起来不错的开源创业公司，做了实验管理、任务执行、模型服务等模块。</li><li>公司内的Kubebrain貌似尝试接入过ClearML，参考<a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=278207933">Kubebrain接入ClearML方案</a>？</li></ul><p><strong>MLOps平台列举</strong></p><ul><li><a href="https://about.mlreef.com/blog/global-mlops-and-ml-tools-landscape">Global MLOps and ML tools landscape</a></li><li><a href="https://thechief.io/c/editorial/top-10-open-source-mlops-tools/">Top 10 Open Source MLOps Tools</a></li><li><a href="https://zhuanlan.zhihu.com/p/375745901"> MLOps: 数据编程时代的工具链创业机会</a></li></ul><h2 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h2><p>在MLOps流程里的最后阶段: Model Serving&#x2F;Deployment是可以单独拿出来聊一下的，因为这一部分其实和Core的同学应该最为密切了。从模型PPL搭建，封装微服务，部署到目标集群，这些都可以宽泛的认为是ModelServing的一部分。但相对于开源一些ModelServing工具来说我们还是有很多不同，大家可以简单对比一下。</p><p><strong><a href="https://github.com/bentoml/Yatai">Yatai</a></strong></p><p><a href="https://www.bilibili.com/video/BV1J34y1e7Ys?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=f58d916e-393c-4423-8418-423ce4267b66&amp;share_source=GENERIC&amp;share_tag=s_i&amp;timestamp=1651273613&amp;unique_k=tE6zzq4">https://www.bilibili.com/video/BV1J34y1e7Ys?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=f58d916e-393c-4423-8418-423ce4267b66&amp;share_source=GENERIC&amp;share_tag=s_i&amp;timestamp=1651273613&amp;unique_k=tE6zzq4</a></p><p>首先是我们的老朋友管锡鹏大佬目前在一个开源创业团队做的工作：</p><ul><li>bentoml下面有两个子项目：<a href="https://github.com/bentoml/BentoML">BentoML</a>，<a href="https://github.com/bentoml/Yatai">Yatai</a><ul><li>BentoML可以通过简单的方法、注解定义，将模型的推理行为对外暴露成RESTFull的接口，并且可以自动攒Batch， 然后和其它基础库封装成一个镜像制品，称之为Bento。</li><li>Yatai提供了简单的UI控制台，将所有模型、Bento制品管理起来，并且可以选择对应版本部署到k8s集群上，并提供对应的日志、监控、跟踪等运维工具。PS：Yatai的界面、功能和MCD如出一辙。</li></ul></li></ul><p><strong><a href="https://kserve.github.io/website/0.8/">KServe</a></strong></p><ul><li>KServe之前叫KFServing，是Kubeflow生态中的一部分，现在独立项目开发。</li><li>KServe利用的开源技术栈比较多，比如Knative+Istio，之前比较重，现在已经变成可选。</li><li>KServe利用Knative实现了模型服务的自动扩缩容，实现了Serverless的能力。</li><li>KServer为了解决多模型的联动的问题，提了一个新的概念：<a href="https://kserve.github.io/website/0.8/modelserving/mms/modelmesh/overview/">ModelMesh</a></li></ul><h3 id="Core工具链对比"><a href="#Core工具链对比" class="headerlink" title="Core工具链对比"></a>Core工具链对比</h3><p>如果抛开具体的模型和业务逻辑，Core目前和ModelServing相关的部分组件：</p><ul><li>MegSDK&#x2F;MegFlow，组装模型PPL，并对外暴露最近本的C&#x2F;gRPC接口。  </li><li>Laserd&#x2F;Demod，负责任务调度，中间件封装，平台接入。</li><li>Saver，负责算法服务编排部署。</li><li>Longinus，负责全局流式任务调度。</li></ul><p>相比于开源社区的ModelServing，Core工具链可能未覆盖的地方：</p><ul><li>底层的平台未迁到k8s底座上，不太方便使用开源工具。</li><li>之前一直没有明确的模型、算法对应的registry，不方便做多版本的管理，目前打算放到AADC。</li><li>对模型的可解释性，算法服务的可观测性集成的工具链不多，运维平台包含了一部分功能。</li><li>模型、算法上线的流程比较简单，没有类似模型热加载、灰度上线、自动扩缩容等功能。</li></ul><p>但Core工具链也有独特的地方：</p><ul><li>因为MegEngine的存在，不需关注差异化的训练框架，反而在不同硬件平台上做了抽象。</li><li>在算法运行时上进行优化，适合多模型PPL组装和高性能计算。</li><li>上层流式任务调度比较完善，适合处理视频流或者消息流。</li></ul><p><strong>Model Serving参考链接</strong></p><ul><li><a href="https://docs.seldon.io/projects/seldon-core/en/stable/workflow/github-readme.html">Seldon Core: Blazing Fast, Industry-Ready ML</a></li><li><a href="https://medium.com/everything-full-stack/machine-learning-model-serving-overview-c01a6aa3e823"> Machine Learning Model Serving Overview (Seldon Core, KFServing, BentoML, MLFlow)</a></li><li><a href="https://github.com/PaddlePaddle/Serving/blob/v0.8.3/README_CN.md">Paddle Serving</a><ul><li>这个应该是旷视MegEngine生态下，ModelServing部分最直接的竞品。</li></ul></li></ul><h2 id="旷视的MLOps？"><a href="#旷视的MLOps？" class="headerlink" title="旷视的MLOps？"></a>旷视的MLOps？</h2><p>前面的资料里谈到的MLOps大部分都是针对通用的机器学习模型，<strong>相对于旷视这种深耕在计算机视觉领域，并且有很多独特业务场景，对软硬件要求都比较高的深度学习模型，很难有现成通用的MLOps解决方案可以参考</strong>。<br>之前我以为将Data++、Brian++、Core串联起来，就可以认为是个MLOps流程。但从目前的模型发版、算法集成来看，还是有很多手动操作的地方，也需要工程化开发投入很多精力，并不是一个自动化的流程。<br>如果创建一个大一统的MLOps平台，应该也是吃力不讨好的事情，它肯定会破坏现在各角色的工作流程，也很难做到灵活扩展。所以旷视的MLOps大概率可以走规范流，通过让不同系统留足接入空间，利用自动化工具打通各系统交接面，解决在面临复杂背景下快速交付模型和算法的问题。</p><h3 id="复杂背景"><a href="#复杂背景" class="headerlink" title="复杂背景"></a>复杂背景</h3><ul><li><strong>模型耦合</strong>：相比互联网场景下，一个大模型或者几个模型就能拼装成预测服务；旷视最经典的人脸算法也是多达近十个模型组合而成，并且模型的输入输出深度绑定，数据传输效率要求较高。这些模型还是由不同R贡献，这就导致从数据、模型、代码的MLOps流程并不是简单的线性模式，有着复杂的耦合关系。<br>目前SDK组的同学承担了很多关于PPL组装的工作，虽然也做了通过规范定义、简单配置、模型外挂的工作来降低模型的耦合性，使模型替换更顺畅，但类似<a href="https://github.com/bentoml/bentoctl">bentoctl</a>这种命令行工具或者UI界面，可以在真实环境自动化更换模型、部署算法服务、验证测试集的工具也可以考虑。</li><li><strong>策略定制</strong>：另外一个旷视算法比较大的特色就是，模型的精度固然重要，但面对实际场景或者长尾场景，R更希望通过灵活的策略代码解决问题，这也是算法仓、检索策略仓、聚档策略仓出现的原因。<br>之前的方案是R用Python将这个策略实现一遍，验证完将代码甩过来，Engineers再用C&#x2F;GO实现一遍，然后频繁往复的对策略对分，有时候并不是策略对不上，可能就是因为语言特性、分布式环境就会有差异。<br>这种场景下，R和Engineers以model为边界的界限就不太适用了，本质上大家都要对model+code的质量负责，而limbo&#x2F;megflow就是为了解决这个问题。此时和<a href="https://github.com/bentoml/BentoML">BentoML</a>类似，limbo&#x2F;megflow提供了搭建模型inference和构建策略PPL的基础工具，R通过直接交付镜像来保证model+code的质量，而Engineers则更多关注硬件平台抽象、数据接入、任务调度、中间件抽象等分布式相关的内容。<br>但这也面临一个问题，是暴露给R的概念越多越好吗？消息队列是抽象一层再暴露吗？如果暴露的太多，是不是Research的心智负担越重？另外开发完一个算法怎么快速部署、验证是恒久的问题，版本管理、打包和授权、可观测和监控怎么办？<br>一个好的PaaS平台不仅要提供合理抽象，还要有完善的工具链来吸引开发者，这一点，公司内的<a href="https://mcd.mcd.megvii-inc.com/docs/manual/#/">MCD</a>比较成功。但MegFlow+AADC面临的问题更复杂一些，不仅要解决算法运行时的效率和灵活性问题，还要解决算法开发、部署、打包、授权等问题，相信会越来越好。</li><li><strong>角色繁多</strong>：MLOps的流程里一般只定义了三类角色，Data Engineers，Data Scientists，ML Engineers，但因为旷视交付的产品一般是软硬结合，限定特定领域的业务产品，所以一个高精度模型&#x2F;算法真实到达客户现场经手的角色可能更多，包括：框架开发人员、业务开发人员、IPU测试，发版人员，交付人员等。在这种情况下，衡量模型&#x2F;算法的生命周期更加困难，每个人了解到信息都是片面的，全靠PM的口头承诺或者晨光大佬的一篇<a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=323351966">wiki</a>来保证。<br>另外，这样容易产生两个问题：一是上游对结果无感知：比如R发了个模型发版邮件就结束了，这个模型被集成在什么megsdk版本？什么时候给到业务用？部署了多少个现场？模型运行效果如何？另一个问题是下游对版本很被动：比如对交付同学，可以查询到现在R正在酝酿发版的有哪些吗？Core当前集成的版本是哪个？有哪些检测模型效果更好，我可以无缝换着试试？<br>当然这两个问题也有可能是我YY的，但总得来说如何有效的衡量模型和算法的Efficiency和Transparency是无论哪种MLOps都要考虑的问题。</li><li><strong>环境割裂</strong>：相比互联网场景下，区分开发测试、线上生产的环境，或者全托管到云厂商的环境，旷视模型生成、部署的环境我认为是相当割裂的。数据的管理、模型训练在公司内相对封闭的Brain++，模型的工程化、集成测试是在公司内裸机器上，最终部署的环境又是客户自己的私有化集群。客户侧私有化环境是和产品绑定的，公司内两个独立的环境也确实能保护数据、模型的安全，但割裂的训练、工程化和推理环境也确实给MLOps的流程带来挑战。<ul><li>首先是<strong>资源相互访问受限</strong>，先不提工程测试环境不像kubebrain一样统一资源管理和调度，两者底层计算、存储资源也无法相互融合，限制了整个公司的资源利用率。这一部分，恩哥之前有过一个<a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=235939318">构想</a>，即使资源的不统一，技术栈上也可以尽量接近。当然，这一部分可能和MLOps关系不太大，应该是底层infra团队可能需要考虑的事情。但在MLOps这个层面，两个环境的数据、模型、代码相互访问受限，也会导致类似下模型&#x2F;数据集要登入Brian++；开发limbo在brain++，测试limbo则需要在工程化环境；Brain++上部署不起来Core等问题。</li><li>然后是<strong>系统边疆感较强，缺少跨系统的CI&#x2F;CD</strong>。因为上诉资源访问受限，再加上部分、角色的束缚，大家更倾向于在各个系统内部建设自动化部署、测试、版本管理的工具链，尽量避免系统间的联动。</li><li>最后则是<strong>很难形成闭环逻辑</strong>，如果说公司内部的训练和工程化通过很hack的手段总是可以互通，客户私有化的环境则很难使MLOps流程形成闭环，让大家忽略模型性能和效果的监控。一方面因为用户数据安全的要求，数据回流很困难；另一方面，模型和算法的模型效果取决于用户的行为，但CBG&#x2F;EBG并不是2C面向大量用户行为的产品，用户反馈的误报、漏报数量不多，参考意义有限。</li></ul></li></ul><p>关于这一部分内容比较啰嗦，也比较偏主观，可能也不太正确，如果你耐心看完，给你点个赞。<br>而且旷视在算法落地面临的挑战可能远不止这些，大家有关于整个流程不够自动化、不够方便易用的点都可以讨论，也为未来设计MLOps流程的同学多参考。</p><h3 id="IPU在做啥？"><a href="#IPU在做啥？" class="headerlink" title="IPU在做啥？"></a>IPU在做啥？</h3><p>目前从我了解到内容，IPU关于MLOps流程的建设主要集中在两个平台：<a href="https://algo-center-doc.mcd.megvii-inc.com/overview/AADC">AADC</a>、<a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=344069199">AI-PaaS</a> </p><ul><li>AADC衔接了公司内的模型训练环境和算法工程化环境，产出是符合规范、可被部署的算法包。</li><li>AI-PaaS衔接了公司内的算法工程化环境和实际部署环境，负责模型、算法的部署以及后续监控、可观测性。</li></ul><p>我只是简单介绍一下，如果有什么遗漏或者错误的地方，可以由对应的研发或者产品再补充一下。 @liujiashuo , @yangkai02 </p><p><strong><a href="https://dev.bistro.sh/">AADC(Algo Application Development Center)</a></strong></p><ul><li>用Gitops管理算法的技术spec信息：algo.yaml, project.json, e2etest.json等。</li><li>集成CI&#x2F;CD的工具，来减少算法构建、授权、测试、发布的手动操作：<ul><li>MegFlow Pack CI: 协助算法开发者将model+code组装成最基本算法制品：image 或者 so，并对外保留规范化的接口：glider.proto&#x2F;megflow.h</li><li>Auth &amp; Encrpt CI: 完成基础制品的授权和加密工作。</li><li>Test CI: 对接QA的测试平台，触发算法仓基础单元测试或者e2e测试。</li><li>Export CI: 发布完备的算法包，无需交付自行手动打包。</li></ul></li><li>公司内算法工程化开发、测试集群统一管理<ul><li>指定集群依托AI-PaaS部署算法，用于开发验证。</li><li>集群资源监控，闲时资源利用，最大化利用集群资源。</li></ul></li><li>公司内算法商城中心<ul><li>已发布算法所有版本管理，历史追踪。</li><li>算法交付审计，统计面向不同BG&#x2F;项目的算法交付情况。</li></ul></li><li>参考链接：<ul><li><a href="https://codimd.mcd.megvii-inc.com/z4E0e0x9QMm4DIp_empdMQ">https://codimd.mcd.megvii-inc.com/z4E0e0x9QMm4DIp_empdMQ</a></li></ul></li></ul><p><strong><a href="https://ai-paas.mcd.megvii-inc.com/docs/Home">AI-PaaS</a></strong></p><ul><li>现场算法仓库中心<ul><li>算法包的上架、授权和激活相关操作。</li></ul></li><li>云-边计算资源管理，算法下发</li><li>流式任务创建和调度</li><li>算法产生的结构化数据汇聚和分发</li><li>参考链接：<ul><li><a href="https://wiki.megvii-inc.com/display/IPU/CEP-51%3A+AI-PaaS">CEP-51: AI-PaaS</a></li></ul></li></ul><h3 id="全流程？"><a href="#全流程？" class="headerlink" title="全流程？"></a>全流程？</h3><p>如果是将MLOps的全流程Run起来，肯定只有IPU的两个平台是不够的。最近翻wiki，也看到上下游部门在做一些事情，可以简单参考一下：</p><ul><li><a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=305922998">AIS</a><ul><li>这一部分，我也觉得比较绕，去年我理解的AIS是Brain++的单独商业版本，但目前好像分了三个版本：AIS公有版，AIS内部版，AIS-Lite？</li><li>其中AIS对内版的算法量产模块，应该是将R算法量产的工具链集成到了AIS内部，然后面向AIT(AI训练师)这个角色，协助他们快速生产和模型。</li><li>AIS的其实覆盖了从数据收集、快速标注、自动训练、模型管理、模型部署整个流程的，但它目前ModelServing这一块应该只是针对单个模型的，和大部分MLOps的开源实现很像。而交付给CBG&#x2F;EBG的算法，大部分都是以PPL+策略代码为主的算法，所以仍需要AADC+AI-PaaS。</li><li>算法量产和AIS的核心目标：<code>KR1：完成CBG/EBG/大项目部等BG的主线算法生产标准化，使用AIS完成模型或PPL生产，覆盖率达到50%以上，AIT团队能够完成50%主线业务的发版和维护承接工作。</code></li><li>参考链接：<ul><li><a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=329558826">2022 算法量产 OKR</a></li><li><a href="https://wiki.megvii-inc.com/display/APUBIZ/2022-Q1+QBR?preview=/351956020/351956433/2022Q1%20QBR%20%E7%AE%97%E6%B3%95%E9%87%8F%E4%BA%A7.pptx">2022Q1 QBR  算法量产.pptx</a></li><li><a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=279664994"> R和AIS合作研发流程</a></li></ul></li></ul></li><li><a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=315264368">ADS(Auto Deploy Service)</a><ul><li>Engine组为了解决不同硬件平台算子的差异，提供给R协助将模型针对硬件选型进行转换的服务。</li><li>将模型转换后，需要配合<a href="https://wiki.megvii-inc.com/display/brainuser/MPP">MMP</a>+MegEngine-Lite才能在硬件平台上运行，目前看MegFlow底层应该是依赖了这两个基础库，完成了在MC40芯片上嵌入式算法仓的实验工作。</li><li>参考链接：<ul><li><a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=346921120">ADS 设计文档</a></li></ul></li></ul></li><li><a href="https://wiki.megvii-inc.com/pages/viewpage.action?pageId=356290494">MDP(Megvii Delivery Platform)</a><ul><li>这个可能和MLOps本身没有多大关系，但如果我们希望将上述这些系统都能部署在k8s底座上，包括私有化版本的AIS，AI-PaaS，甚至悟空这样的业务产品，则需要一个解决方案交付流程。</li><li>MDP是参照阿里的<a href="https://help.aliyun.com/document_detail/193132.html">ADP</a>，根据旷视特色自己设计的一套云原生解决方案交付流程。</li></ul></li></ul><p>综合上面所有的系统，我们其实可以大概组装出旷视在建设的MLOps流程：</p><p><img src="/images/2022-05-20-mlops/img-2022-05-23-01-17-46.png"><br>这个也是基于xxr的图，自己脑补的，有什么问题都可以指正。另外这些系统可能和恩哥都有点关系，有啥问题也可以多和恩哥聊，抱紧恩哥大腿。将这些系统组合起来，可以发现，如果列举的功能模块都比较完善的话，有没有可能达到一个我们理想的MLOps流程：</p><p><strong>对一个大致料了解深度学习是什么，会一点Python的同学，姑且我们也称为AI训练师。在面临一个特定的算法问题时：</strong><br><strong>- 他不需要了解业界最好的模型结构是什么？ -&gt; AIS&#x2F;算法量产&#x2F;snapx</strong><br><strong>- 他不需要了解最终跑的硬件平台是什么？ -&gt; ADS&#x2F;MMP</strong><br><strong>- 他不需要了解怎么搭建高性能的InferenceServer？ -&gt; MegFlow</strong><br><strong>- 他不需要了解保护代码和模型，怎么打包？ -&gt; AADC</strong><br><strong>- 他不需要了解视频流怎么接入、任务调度、扩缩容、k8s？ -&gt; AI-PaaS</strong></p><p><strong>他可以不用写任何胶水代码，不用自己搭CI&#x2F;CD，只需要在上诉四个系统：AIS-&gt;ADS-&gt;AADC-&gt;AI-PaaS的UI界面上点来点去，就可以一个人(或者加一个交付) 将一个高效的、经过验证的、可产品化的模型&#x2F;算法部署到业务侧。在整个过程中，不需要高级研究员、框架开发、工程化开发、QA等同学的介入，最大程度地达到自动化流程。</strong></p><h2 id="MLOps-Sig"><a href="#MLOps-Sig" class="headerlink" title="MLOps-Sig"></a>MLOps-Sig</h2><p>前面提到，走规范流的MLOps并不是强调建立一个统一大平台入口，将所有关于数据集、模型、算法、部署的管理都放进去，而是更注重组织间的规范合作，业务流程，自动化水平。这显然靠单个平台的开发者推广是很难的，肯定是希望更多的同学尽量参与，不仅是研发，包括PM、测试等同学。这样大家对全景有个概念，后面开发相关工具的时候就可以有参考，慢慢地靠拢到一个流程。<br>那怎么样让大家在一个地方交流呢？最近，罗少和恩哥应该会组织一些sig小组来让更多感兴趣的同学参与到类似MLOps，DevOps，DataOps的讨论当中。目前Sigs已经成为开源社区管理特定主题的方法，详细可以参考<a href="https://github.com/kubernetes/community/blob/master/governance.md#sigs">k8s-sigs</a>。虽然我没做过啥开源社区贡献，比较low，但是如果后续有mlops-sig开展起来，我也想提供一些建议：</p><ul><li><strong>用Git管理文档</strong>：sig里面比较重要的就是管理大家的共识，包括：讨论主题、Feature&amp;Roadmap、架构图、日常同步章程、术语和规范、主席和成员等等，但不适宜放一些开发记录、bug讨论等内容。用Git管理则可以记录历史变更，提倡每个人都可以进行讨论和更改架构。</li><li><strong>上下游的边界</strong>：sig小组覆盖完整上下游部门肯定是大家希望见到的，但无论怎样，了解上下游部门在做什么都是必要的。一方面，定义清楚各系统的边界面，共同维护数据规范，比如：模型打包格式、Megflow算法仓specs、算法包打包格式、任务创建格式、算法事件格式等，可以让开发的系统不耦合在一起，也不易出现扒接口的情况。另一方面，了解上下游实现的细节，多和其它部门同学聊天，多翻其它部门wiki，可以让大家对整体架构有更清晰的认识。其实，画上面那个图的时候，我也是比较虚的，只是描述了大致的功能流程；如果后面sig小组成立，可以细的了解上下游部门的实现，绘制更完整的模块架构图。</li><li><strong>UI界面易接受</strong>：说实在的，目前应用比较广的两个平台性产品：Devops 和 MCD，在界面易用性其实都很不错，主要是因为它们的开发者天伟和锡鹏都来自豆瓣，对前端全栈开发都比较熟。平台开发后，推广使用阶段一般都可以提供三种方式：ctl工具，api接口文档，Dashboard。而Dashboard相比较而言，更容易体现一个用户的使用流程，完成用户故事；也能吸引大家随便点点，反馈更多问题。这也是core-ui虽然很简单，也吸引很多交付使用的原因。所以这也就要求PM花时间在原型图设计，研发在前端界面上求自己或者求他人。</li><li><strong>云原生与Infra</strong>：其实MLOps流程和云原生并没有直接的联系，即使是在k8s流行之前，传统的机器学习也可以走MLOps流程。但云原生相关的技术大大减少重复造轮子的工作量，也能统一资源管理，减少资源浪费。目前看好像只有AI-PaaS还不能完全部署在k8s底座上面，后续可以考虑。另外，平台开发中可能用到的：pipeline、GPU虚拟化、边端集群管理、流量管理、Serverless、容器调度，都可以联系Infra团队来提供对应的能力，而上层平台则更foucus在抽象的合理性、功能的易用性。</li><li><strong>关注开源社区</strong>：前面提到，无论是大的云厂商，还是一些创业公司都在做MLOps。关注一些开源项目，一方面可以了解一些新的技术和概念，扩充自己的知识面，把一些优先的想法引入到mlops-sig中；另一方面，因为旷视是深耕在视觉领域，业务大部分也是2B，所以如果对外向技术相关的人员解释我们的业务流更困难一些，但如果用一些开源的概念做类比，就比较顺畅一些，比较大家本质解决的问题是类似的。</li></ul><h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p>好了！两篇关于MLOps的介绍就到此结束了。文字表达上可能比较琐碎，但也总归融入了一些我的想法。</p><p>无论后面大家是做MLOps还是谈论MLOps，如果这两篇文章能帮助到大家，就万分荣幸了！谢谢大家！ </p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BA%8F&quot;&gt;序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF&quot;&gt;问题背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFmlops&quot;&gt;什么是MLOps？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%83%E7%B4%A0%E8%A7%92%E8%89%B2%E6%B5%81%E7%A8%8B&quot;&gt;元素、角色、流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%8D%E8%AF%8D%E5%AF%B9%E6%AF%94&quot;&gt;名词对比&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0&quot;&gt;开源实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3&quot;&gt;部署相关&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#core%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AF%B9%E6%AF%94&quot;&gt;Core工具链对比&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%B7%E8%A7%86%E7%9A%84mlops&quot;&gt;旷视的MLOps？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%8D%E6%9D%82%E8%83%8C%E6%99%AF&quot;&gt;复杂背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ipu%E5%9C%A8%E5%81%9A%E5%95%A5&quot;&gt;IPU在做啥？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%A8%E6%B5%81%E7%A8%8B&quot;&gt;全流程？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#mlops-sig&quot;&gt;MLOps-Sig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BB%88&quot;&gt;终&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;MLOps这个概念最近比较流行，晨光也发了一些&lt;a href=&quot;https://ipu-discourse.megvii-inc.com/t/topic/1549&quot;&gt;Link&lt;/a&gt;给大家参考。之前在做&lt;a href=&quot;https://ipu-discourse.megvii-inc.com/t/topic/1579/3&quot;&gt;Saver&lt;/a&gt;和介绍&lt;a href=&quot;https://wiki.megvii-inc.com/pages/viewpage.action?pageId=34896780&amp;preview=/34896780/299343248/Model%20Serving.pptx&quot;&gt;ModelServing&lt;/a&gt;的过程中，查过一些资料，可以整理一下供大家参考。MLOps涵盖的概念比较多，我也是不求甚解，有兴趣可以多了解一些，对于IPU可以在公司内MLOps上做什么也可以多讨论。&lt;/p&gt;</summary>
    
    
    
    <category term="MLOps" scheme="https://zhangfei614.github.io/categories/MLOps/"/>
    
    
    <category term="ModelServing" scheme="https://zhangfei614.github.io/tags/ModelServing/"/>
    
    <category term="Megvii" scheme="https://zhangfei614.github.io/tags/Megvii/"/>
    
  </entry>
  
  <entry>
    <title>2022-job-codes</title>
    <link href="https://zhangfei614.github.io/2022/01/02/2022-job-codes/"/>
    <id>https://zhangfei614.github.io/2022/01/02/2022-job-codes/</id>
    <published>2022-01-02T05:54:14.000Z</published>
    <updated>2022-05-28T15:06:45.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><ul><li>使用数组模拟stack时，记得从后面push，pop</li></ul></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><ul><li>处理顺序和访问顺序不一致，要先将左孩子全部压栈后才能开始处理节点。</li><li><code> for cur != nil || len(stack) != 0 &#123; if cur != nil &#123;stack = append(stack, cur); cur = cur.Left&#125;&#125; else &#123; top = stack.pop(); res = append(res, res.Val); cur = top.Right&#125;</code></li></ul></li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a><ul><li>要通过一个pre指针记录右子树是否已经处理完成，如果右子树为空||右子树&#x3D;&#x3D;pre，才处理。</li><li>否则将自己重新入栈回去，等待下一次处理。</li><li><code>for cur != nil || len(stack) != 0 &#123;if cur != nil &#123;stack = append(strack,cur); cur = cur.Left&#125;else &#123;node := stack.pop(); if node.Right == nil || node.Right == pre &#123; res = append(res); pre = node; cur = nil&#125;else&#123; stack = append(stack, node); cur = cur.Right&#125;&#125;&#125;</code></li></ul></li><li><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%BB%E7%BB%93">统一迭代法</a><ul><li>通过加入空指针来控制要处理的节点后面，然后来达到对处理节点特殊逻辑的作用。</li><li>后序为例：<code>stack.push(root); for !stack.empty()&#123;node := stack.pop(); if node != nil&#123;stack.push(left,right,node)&#125;else&#123;res = append(res, stack.pop().val())&#125;</code></li></ul></li></ul><span id="more"></span>  <ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a><ul><li>size要先读，直接使用append</li></ul></li><li><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a><ul><li>递归方法：本质就是使用前序遍历的方法，交换左右子树。</li><li>迭代方法：可以在前序、后序、层序三种选择一种，中间的append换成swap</li></ul></li><li><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a><ul><li>递归方法：本质是两个前序遍历的配合：&#96;if a &#x3D;&#x3D; nil &amp;&amp; b &#x3D;&#x3D; nil {return true}; if a&#x3D;&#x3D; nil || b &#x3D;&#x3D; nil {return false}; return a.Val &#x3D;&#x3D; b.Val &amp;&amp; check(a.Left, b.Right) &amp;&amp; check(a.Right, b.Left)</li><li>迭代方法：使用前后队列来将需要比对的值，分别append到前和后。也可是使用栈，每次append一对。</li></ul></li><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a><ul><li>递归做法：return root&#x3D;&#x3D; nil ? 0: 1 + math.MaxInt(hight(root.Left), hight(root.Right))</li><li>迭代方法：层次遍历&#x3D;&#x3D;BFS</li></ul></li><li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/submissions/">111. 二叉树的最小深度</a><ul><li>只有左右子树都不为空的时候，才返回1+min</li></ul></li><li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a><ul><li>如果不平衡，直接返回-1</li></ul></li><li><a href="https://leetcode-cn.com/problems/binary-tree-paths/submissions/">257. 二叉树所有路径</a><ul><li>直接使用slice的[:2]避免root节点的特殊处理</li></ul></li><li><a href="https://leetcode-cn.com/problems/path-sum/submissions/">112. 路径和</a><ul><li>非叶子节点执行左右递归并取或</li></ul></li><li><a href="https://leetcode-cn.com/problems/path-sum-ii/submissions/">113. 路径和II</a><ul><li>回溯法记录路径</li></ul></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/">106. 中序和后序构建二叉树</a><ul><li><code>lib,lie, lpb,lpe := ib, index-1, pb, pb + (index-1-ib)</code></li><li><code>rib,rie, rpb, rpe := index +1, ie, pe-1-(ie-index-1), pe-1</code></li></ul></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/">105. 前序和中序构建二叉树</a><ul><li><code>lpb,lpe,lib,lie := pb+1, pb+1+(index-1-ib), ib, index -1</code></li><li><code>rpb,rpe,rib,rie := pe-(ie-index-1),pe,index+1, ie</code></li></ul></li><li><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/submissions/">617. 合并二叉树</a></li><li><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/submissions/">700. 二叉树中的搜索</a></li><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/">98. 验证二叉搜索树</a><ul><li>递归要记录pre的值</li><li>非递归可以使用栈来模拟中序遍历，并记录前一个节点。</li></ul></li><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/">530. 二叉搜索树的最小绝对差</a><ul><li>和上体基本一样，<code>res := int(^zero&gt;&gt;1)</code></li></ul></li><li><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/submissions/">1530. 好叶子节点对的数量</a><ul><li>利用后续遍历每个节点，返回每个节点到其叶子节点的距离，然后来判断路径和</li></ul></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/">236. 二叉树的最近公共祖先</a><ul><li>左右子树都要遍历，将找到的节点一路返回。</li><li><code>left := lowestCommonAncestor(root.Left, p, q);right := lowestCommonAncestor(root.Right, p, q) ;if left != nil &amp;&amp; right != nil&#123;return root&#125;;if left == nil &amp;&amp; right != nil&#123;return right&#125;;if left != nil &amp;&amp; right == nil&#123;return left&#125;</code></li></ul></li><li><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/">701. 二叉搜索树中的插入操作</a> </li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/">450. 删除二叉搜索树中的节点</a><ul><li>删除的时候根据具体情况分类，如果左右节点都有，要将右孩子提上去，左孩子放到右树的最左侧。</li></ul></li><li><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/">669. 修剪二叉搜索树</a><ul><li>if root.Val &lt; low {return trimBST(root.Right, low, high)}<br>if root.Val &gt; high {return trimBST(root.Left, low, high)}<br>root.Left &#x3D; trimBST(root.Left, low, high)<br>root.Right &#x3D; trimBST(root.Right, low, high)</li></ul></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">206. 反转链表</a><ul><li>递归：newHead &#x3D; reverse(head.next); head.next.next &#x3D; head; head.next &#x3D; nil; return newHead</li><li>非递归：虚拟头结点，遍历插入</li></ul></li><li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/submissions/">108. 将有序数组转换为二叉搜索树</a></li></ul><p>总结：</p><ul><li><p>二叉树尽量使用递归，定义好递归的返回值。</p></li><li><p>公共祖先的问题可以返回一个vector来做。<br>  ·</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2></li><li><p>[63. 不同路径II]</p><ul><li>初始化时记得横竖如果有障碍则没办法向后初始化。<ul><li>for (int i &#x3D; 0; i &lt; m &amp;&amp; obstacleGrid[i][0] &#x3D;&#x3D; 0; i++) dp[i][0] &#x3D; 1;</li></ul></li><li>递归表达式：<ul><li>if (obstacleGrid[i][j] &#x3D;&#x3D; 1) continue;</li><li>dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];</li></ul></li></ul></li><li><p>[343. 拆分整数]</p><ul><li>for (int j &#x3D; 1; j &lt; i; j++) {<br>curMax &#x3D; Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));<br>}</li></ul></li><li><p>[96. 不同的二叉搜索树]</p><ul><li>dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</li></ul></li></ul><p>总结：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&quot;&gt;144. 二叉树的前序遍历&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;使用数组模拟stack时，记得从后面push，pop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/&quot;&gt;94. 二叉树的中序遍历&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;处理顺序和访问顺序不一致，要先将左孩子全部压栈后才能开始处理节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; for cur != nil || len(stack) != 0 &amp;#123; if cur != nil &amp;#123;stack = append(stack, cur); cur = cur.Left&amp;#125;&amp;#125; else &amp;#123; top = stack.pop(); res = append(res, res.Val); cur = top.Right&amp;#125;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-postorder-traversal/&quot;&gt;145. 二叉树的后序遍历&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;要通过一个pre指针记录右子树是否已经处理完成，如果右子树为空||右子树&amp;#x3D;&amp;#x3D;pre，才处理。&lt;/li&gt;
&lt;li&gt;否则将自己重新入栈回去，等待下一次处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for cur != nil || len(stack) != 0 &amp;#123;if cur != nil &amp;#123;stack = append(strack,cur); cur = cur.Left&amp;#125;else &amp;#123;node := stack.pop(); if node.Right == nil || node.Right == pre &amp;#123; res = append(res); pre = node; cur = nil&amp;#125;else&amp;#123; stack = append(stack, node); cur = cur.Right&amp;#125;&amp;#125;&amp;#125;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%BB%E7%BB%93&quot;&gt;统一迭代法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;通过加入空指针来控制要处理的节点后面，然后来达到对处理节点特殊逻辑的作用。&lt;/li&gt;
&lt;li&gt;后序为例：&lt;code&gt;stack.push(root); for !stack.empty()&amp;#123;node := stack.pop(); if node != nil&amp;#123;stack.push(left,right,node)&amp;#125;else&amp;#123;res = append(res, stack.pop().val())&amp;#125;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Job" scheme="https://zhangfei614.github.io/categories/Job/"/>
    
    
  </entry>
  
  <entry>
    <title>WIP:seldon-core简介</title>
    <link href="https://zhangfei614.github.io/2021/08/16/seldon-core-intro/"/>
    <id>https://zhangfei614.github.io/2021/08/16/seldon-core-intro/</id>
    <published>2021-08-16T15:47:10.000Z</published>
    <updated>2022-05-28T15:06:45.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="部署minikube-amp-istio-amp-seldon-core"><a href="#部署minikube-amp-istio-amp-seldon-core" class="headerlink" title="部署minikube &amp; istio &amp; seldon-core"></a>部署minikube &amp; istio &amp; seldon-core</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装istio</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#更改istio为NodePort方式</span></span><br><span class="line"> kubectl patch service istio-ingressgateway -n istio-system -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;type&quot;:&quot;NodePort&quot;&#125;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tmux开启istio-ingressgateway的port-forward</span></span><br><span class="line">kubectl port-forward -n istio-system --address 0.0.0.0 service/istio-ingressgateway 7080:80</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装seldon-core</span></span><br><span class="line"><span class="comment">#创建namespace</span></span><br><span class="line">kubectl create namespace seldon-system</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装使用istio的seldon-core</span></span><br><span class="line">helm install seldon-core seldon-core-operator \</span><br><span class="line">    --repo https://storage.googleapis.com/seldon-charts \</span><br><span class="line">    --<span class="built_in">set</span> usageMetrics.enabled=<span class="literal">true</span> \</span><br><span class="line">    --namespace seldon-system \</span><br><span class="line">    --<span class="built_in">set</span> istio.enabled=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#部署模型</span></span><br><span class="line">kubectl create namespace seldon</span><br><span class="line">kubectl apply -f - &lt;&lt; <span class="string">END</span></span><br><span class="line"><span class="string">apiVersion: machinelearning.seldon.io/v1</span></span><br><span class="line"><span class="string">kind: SeldonDeployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: iris-model</span></span><br><span class="line"><span class="string">  namespace: seldon</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  name: iris</span></span><br><span class="line"><span class="string">  predictors:</span></span><br><span class="line"><span class="string">  - graph:</span></span><br><span class="line"><span class="string">      implementation: SKLEARN_SERVER</span></span><br><span class="line"><span class="string">      modelUri: gs://seldon-models/v1.10.0-dev/sklearn/iris</span></span><br><span class="line"><span class="string">      name: classifier</span></span><br><span class="line"><span class="string">    name: default</span></span><br><span class="line"><span class="string">    replicas: 1</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问</span></span><br><span class="line">http://10.122.101.60:7080/seldon/seldon/iris-model/api/v1.0/doc/<span class="comment">#/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.jianshu.com/p/52454bd8f516">istio 1.8.2安装及可观测性配置</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;部署minikube-amp-istio-amp-seldon-core&quot;&gt;&lt;a href=&quot;#部署minikube-amp-istio-amp-seldon-core&quot; class=&quot;headerlink&quot; title=&quot;部署minikube &amp;amp; ist</summary>
      
    
    
    
    <category term="MLOps" scheme="https://zhangfei614.github.io/categories/MLOps/"/>
    
    
    <category term="k8s" scheme="https://zhangfei614.github.io/tags/k8s/"/>
    
    <category term="ModelServing" scheme="https://zhangfei614.github.io/tags/ModelServing/"/>
    
  </entry>
  
  <entry>
    <title>WIP:《深度学习之PyTorch物体检测实战》笔记</title>
    <link href="https://zhangfei614.github.io/2021/08/12/pytorch-detection-reading-note/"/>
    <id>https://zhangfei614.github.io/2021/08/12/pytorch-detection-reading-note/</id>
    <published>2021-08-12T00:19:00.000Z</published>
    <updated>2022-05-28T15:06:45.950Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Tensor:</p><ul><li>grad: 对应梯度，类型为Tensor，维度相同。</li><li>grad_fn: 指向的function对象，经历了怎样的操作。</li><li>backword()：<ul><li>动态图特性，每次前向传播从头开始构建计算图。</li><li>grac_variables，根节点导数&#x3D;&#x3D;根节点权重系数。</li><li>retain_graph，多个输出反向求导设置为True。</li></ul></li></ul><p>torch.nn:</p><ul><li>nn.Module:神经网络类。</li><li>nn.Parameter:默认需要求导的参数。</li><li>forward():定义类的前向传播。</li><li>nn.functional:不需要进行参数学习的层。</li><li>nn.Sequential():快速搭建模型各层。</li><li>nn.optim: 优化算法，SGD，Adam，Adagrad等</li></ul><!-- more ---><p>神经网络基本组成：</p><ul><li>卷积层：提取数据特征，根据卷积核扫描矩阵。</li><li>激活函数：非线性函数表达复杂空间。<ul><li>sigmod: 适合二分类，计算量大，梯度小时。</li><li>ReLU：计算简短，收敛快，但负区域输入值都为0。</li><li>Leaky ReLU: 负区域赋予很小的权重。</li><li>softmax：多分类使用。</li></ul></li><li>池化层：降低特征图的参数量，提升计算速度，增加感受野，比如：Max Pooling，Average Pooling。</li><li>Dropout层：<ul><li>参数过多而训练样本较少，模型容易产生过拟合现象。</li><li>在训练时，每个神经元以概率p保留，即以概率 1-p 的概率停止工作。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h4&gt;&lt;p&gt;Tensor:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grad: 对应梯度，类型为Tensor，维度相同。&lt;/li&gt;
&lt;li&gt;grad_</summary>
      
    
    
    
    <category term="DeepLearning" scheme="https://zhangfei614.github.io/categories/DeepLearning/"/>
    
    
    <category term="DeepLearning" scheme="https://zhangfei614.github.io/tags/DeepLearning/"/>
    
    <category term="PyTorch" scheme="https://zhangfei614.github.io/tags/PyTorch/"/>
    
    <category term="Detection" scheme="https://zhangfei614.github.io/tags/Detection/"/>
    
  </entry>
  
  <entry>
    <title>红黑树详解</title>
    <link href="https://zhangfei614.github.io/2017/06/13/Red-Black-Tree/"/>
    <id>https://zhangfei614.github.io/2017/06/13/Red-Black-Tree/</id>
    <published>2017-06-13T07:12:22.000Z</published>
    <updated>2022-05-28T15:06:45.952Z</updated>
    
    <content type="html"><![CDATA[<h4 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h4><p>红黑树一种特殊的二叉查找树，在多种语言的多种数据结构中都有实现，查询效率较高。其特性是：</p><ul><li>每个节点或者黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子结点（NIL）是黑色。</li><li>如果一个结点是红色，它的子节点必须是黑色。</li><li>从一个结点到该节点的子孙叶子结点的所有路径上包含相同数目的黑色结点。（确保没有一条路径会比其他路径长出两倍，接近于平衡二叉树。）</li></ul><p>![Alt text](&#x2F;images&#x2F;Red-Black Tree&#x2F;1490578618842.png)</p><h4 id="红黑树的时间复杂度"><a href="#红黑树的时间复杂度" class="headerlink" title="红黑树的时间复杂度"></a>红黑树的时间复杂度</h4><p><strong>定理：一棵含有n个结点的红黑树的高度之多为$2log(n+1)$</strong><br>可以通过证明：高度为h的红黑树，他的包含的内节点的个数至少为$2^{h&#x2F;2}-1$个。</p><span id="more"></span><h4 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h4><p><strong>左旋</strong><br>对X进行左旋，意味着，将“X的右孩子”设为“X的父亲节点”；即，将 X变成了一个左节点。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。<br>![Alt text](&#x2F;images&#x2F;Red-Black Tree&#x2F;1491482439906.png)</p><p>《算法导论》伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)  </span><br><span class="line"> y ← right[x]            <span class="comment">// 前提：这里假设x的右孩子为y。下面开始正式操作</span></span><br><span class="line"> right[x] ← left[y]      <span class="comment">// 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span></span><br><span class="line"> p[left[y]] ← x          <span class="comment">// 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span></span><br><span class="line"> p[y] ← p[x]             <span class="comment">// 将 “x的父亲” 设为 “y的父亲”</span></span><br><span class="line"> <span class="keyword">if</span> p[x] = nil[T]       </span><br><span class="line"> root[T] ← y         <span class="comment">// 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span></span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="type">if</span> <span class="variable">x</span> <span class="operator">=</span> left[p[x]]  </span><br><span class="line"><span class="comment">// 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></span><br><span class="line">        left[p[x]] ← y </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">    <span class="comment">// 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span></span><br><span class="line">    right[p[x]] ← y   </span><br><span class="line"> left[y] ← x             <span class="comment">// 将 “x” 设为 “y的左孩子”</span></span><br><span class="line"> p[x] ← y                <span class="comment">// 将 “x的父节点” 设为 “y”</span></span><br></pre></td></tr></table></figure><p><strong>右旋</strong><br>对X进行右旋，意味着，将“X的左孩子”设为“X的父亲节点”；即，将X变成了一个右节点。因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。<br>![Alt text](&#x2F;images&#x2F;Red-Black Tree&#x2F;1491485291292.png)<br>《算法导论》伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)  </span><br><span class="line"> x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作</span><br><span class="line"> left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span><br><span class="line"> p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span><br><span class="line"> p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”</span><br><span class="line"> if p[y] = nil[T]       </span><br><span class="line">   root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span><br><span class="line"> else </span><br><span class="line"> if y = right[p[y]]  </span><br><span class="line">        right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span><br><span class="line">     else </span><br><span class="line">     left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span><br><span class="line"> right[x] ← y            // 将 “y” 设为 “x的右孩子”</span><br><span class="line"> p[y] ← x                // 将 “y的父节点” 设为 “x”</span><br></pre></td></tr></table></figure><h4 id="红黑树的添加"><a href="#红黑树的添加" class="headerlink" title="红黑树的添加"></a>红黑树的添加</h4><p><strong>执行步骤：</strong></p><ol><li>将红黑树作为二叉查找树，将结点插入。</li><li>将插入结点的颜色置为”红色”。</li><li>通过旋转或者着色等操作，将二叉树重新变为一个红黑树。<ul><li>如果被插入节点是根节点，则直接将该结点涂为黑色。</li><li>如果被插入节点的父节点是黑色，则不需要处理，认为红黑树。</li><li>如果被插入节点的父节点是红色，则需要根据叔叔结点的情况进行进一步处理。</li></ul></li></ol><p><strong>对红色结点的调整</strong></p><table><thead><tr><th>Case</th><th>现象说明</th><th align="center">处理策略</th></tr></thead><tbody><tr><td>Case 1</td><td>当前节点的父节点是红色，叔叔节点也是红色。</td><td align="center">(01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)</td></tr><tr><td>Case 2</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td><td align="center">(01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。</td></tr><tr><td>Case 3</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td><td align="center">(01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。</td></tr><tr><td>![Alt text](&#x2F;images&#x2F;Red-Black Tree&#x2F;1491531856578.png)</td><td></td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;<span class="comment">//如果y为null，则视为BLACK</span></span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树的删除操作"><a href="#红黑树的删除操作" class="headerlink" title="红黑树的删除操作"></a>红黑树的删除操作</h4><p><strong>执行步骤：</strong></p><ol><li><p>将红黑树作为二叉查找树，将节点删除。</p><ul><li>如果是叶节点，直接将叶节点删除。</li><li>如果删除结点只有一个儿子，将其子节点顶替其位置。</li><li>如果有两个非空子节点，则需要找出其后继节点。然后把后继节点替换到当前位置，并递归地删除后继节点。</li></ul></li><li><p>通过“旋转和着色”来修正该树，使之重新成为一颗红黑树。</p></li></ol><p><strong>基本思想：</strong><br>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p><p>删除修复操作分为四种情况(删除黑节点后)：</p><ul><li>待删除的节点的兄弟节点是红色的节点。</li><li>待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。</li><li>待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。</li><li>待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。</li></ul><p><strong>对黑色结点的调整</strong></p><table><thead><tr><th>Case</th><th>现象说明</th><th>处理方案</th></tr></thead><tbody><tr><td>Case 1</td><td>X是黑色结点，X的兄弟是红色结点，并且X的兄弟的子节点都是黑色节点</td><td>(01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。（无法从兄弟结点借调黑色结点，将兄弟结点上升，从兄弟结点的子节点借调，将其转换为Case 2,3,4）</td></tr><tr><td>Case 2</td><td>X是黑色结点，X的兄弟是黑色结点，并且X的兄弟的子节点都是黑色节点。</td><td>(01) 将x的兄弟节点设为“红色”。(02) 设当前结点为X的父节点。（把兄弟结点变红后，有可能导致祖父结点失去平衡，因此需要回溯到父节点进行调整。）</td></tr><tr><td>Case 3</td><td>X是黑色结点，X的兄弟是黑色结点，兄弟结点的左孩子是红色结点。</td><td>(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。（中间状态，借用侄子结点的红色，变成黑色来平衡查找树。）</td></tr><tr><td>Case 4</td><td>X是黑色结点，X的兄弟是黑色结点，兄弟结点的右孩子是红色结点。</td><td>(01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。（将兄弟结点的左黑色结点借调过来。）</td></tr><tr><td>![Alt text](&#x2F;images&#x2F;Red-Black Tree&#x2F;1491572932688.png)</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除操作总结：</strong><br>红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p><p>对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。</p><p>对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。</p><p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。</p><h4 id="红黑树Java实现"><a href="#红黑树Java实现" class="headerlink" title="红黑树Java实现"></a>红黑树Java实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.tsinghua.zhangfei.datastructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Fei Zhang on 2017/4/7.</span></span><br><span class="line"><span class="comment"> * Email:zhangfei614@126.com</span></span><br><span class="line"><span class="comment"> * - 每个节点或者黑色，或者是红色。</span></span><br><span class="line"><span class="comment"> * - 根节点是黑色。</span></span><br><span class="line"><span class="comment"> * - 每个叶子结点（NIL）是黑色。</span></span><br><span class="line"><span class="comment"> * - 如果一个结点是红色，它的子节点必须是黑色。</span></span><br><span class="line"><span class="comment"> * - 从一个结点到该节点的子孙叶子结点的所有路径上包含相同数目的黑色结点。（确保没有一条路径会比其他路径长出两倍，接近于平衡二叉树。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBTree</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RBNode&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RBNode</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        T value;</span><br><span class="line">        RBNode&lt;T&gt; left;</span><br><span class="line">        RBNode&lt;T&gt; right;</span><br><span class="line">        RBNode&lt;T&gt; parent;</span><br><span class="line">        <span class="type">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        RBNode(T value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RBNode(T value, <span class="type">boolean</span> color, RBNode&lt;T&gt; parent, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RBTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对X进行左旋，意味着，将“X的右孩子”设为“X的父亲节点”；</span></span><br><span class="line"><span class="comment">     * 即，将 X变成了一个左节点。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(RBNode&lt;T&gt; node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">r</span> <span class="operator">=</span> node.right;</span><br><span class="line">            node.right = r.left;</span><br><span class="line">            <span class="keyword">if</span> (r.left != <span class="literal">null</span>)</span><br><span class="line">                r.left.parent = node;</span><br><span class="line">            r.parent = node.parent;</span><br><span class="line">            <span class="keyword">if</span> (node.parent == <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.root = r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left)</span><br><span class="line">                node.parent.left = r;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.parent.right = r;</span><br><span class="line">            r.left = node;</span><br><span class="line">            node.parent = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对X进行右旋，意味着，将“X的左孩子”设为“X的父亲节点”；</span></span><br><span class="line"><span class="comment">     * 即，将X变成了一个右节点。因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(RBNode&lt;T&gt; node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">l</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = l.right;</span><br><span class="line">            <span class="keyword">if</span> (l.right != <span class="literal">null</span>)</span><br><span class="line">                l.right.parent = node;</span><br><span class="line">            l.parent = node.parent;</span><br><span class="line">            <span class="keyword">if</span> (node.parent == <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.root = l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.parent.left == node)</span><br><span class="line">                node.parent.left = l;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.parent.right = l;</span><br><span class="line">            l.right = node;</span><br><span class="line">            node.parent = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RBNode <span class="title function_">find</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        <span class="type">RBNode</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            cmp = value.compareTo((T) t.value);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一个值：</span></span><br><span class="line"><span class="comment">     * 1. 将红黑树作为二叉查找树，将结点插入。</span></span><br><span class="line"><span class="comment">     * 2. 将插入结点的颜色置为&quot;红色&quot;。</span></span><br><span class="line"><span class="comment">     * 3. 通过旋转或者着色等操作，将二叉树重新变为一个红黑树。</span></span><br><span class="line"><span class="comment">     * 如果有值，则返回引用；没有值则返回null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RBNode <span class="title function_">insert</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        RBNode parent, t = <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="comment">//如果根为空，则直接插入。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RBNode</span>(value);</span><br><span class="line">            <span class="built_in">this</span>.root = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = value.compareTo((T) t.value);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        <span class="type">RBNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RBNode</span>(value, RED, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = node;</span><br><span class="line">        fixAfterInsertion(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入值后的调整：</span></span><br><span class="line"><span class="comment">     * - 如果被插入节点是根节点，则直接将该结点涂为黑色。</span></span><br><span class="line"><span class="comment">     * - 如果被插入节点的父节点是黑色，则不需要处理，认为红黑树。</span></span><br><span class="line"><span class="comment">     * - 如果被插入节点的父节点是红色，则需要根据叔叔结点的情况进行进一步处理。</span></span><br><span class="line"><span class="comment">     * | Case 1|当前节点的父节点是红色，叔叔节点也是红色。| (01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)|</span></span><br><span class="line"><span class="comment">     * | Case 2|当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子 | (01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。|</span></span><br><span class="line"><span class="comment">     * | Case 3|当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子|(01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。|</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(RBNode node)</span> &#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node != root &amp;&amp; colorOf(parentOf(node))== RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parentOf(node) == leftOf(parentOf(parentOf(node)))) &#123;</span><br><span class="line">                <span class="type">RBNode</span> <span class="variable">uncle</span> <span class="operator">=</span> rightOf(parentOf(parentOf(node)));</span><br><span class="line">                <span class="comment">//case 1</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(uncle) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(node),BLACK);</span><br><span class="line">                    setColor(uncle,BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(node)),RED);</span><br><span class="line">                    node = parentOf(parentOf(node));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//case 2</span></span><br><span class="line">                    <span class="keyword">if</span> (node == rightOf(parentOf(node))) &#123;</span><br><span class="line">                        node = parentOf(node);</span><br><span class="line">                        leftRotate(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//case 3</span></span><br><span class="line">                    setColor(parentOf(node),BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(node)),RED);</span><br><span class="line">                    rightRotate(parentOf(parentOf(node)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RBNode</span> <span class="variable">uncle</span> <span class="operator">=</span> leftOf(parentOf(parentOf(node)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(uncle) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(node),BLACK);</span><br><span class="line">                    setColor(uncle,BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(node)),RED);</span><br><span class="line">                    node = parentOf(parentOf(node));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == leftOf(parentOf(node))) &#123;</span><br><span class="line">                        node = parentOf(node);</span><br><span class="line">                        rightRotate(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(node),BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(node)),RED);</span><br><span class="line">                    leftRotate(parentOf(parentOf(node)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个值：</span></span><br><span class="line"><span class="comment">     * 1. 将红黑树作为二叉查找树，将节点删除。</span></span><br><span class="line"><span class="comment">     * - 如果是叶节点，直接将叶节点删除。</span></span><br><span class="line"><span class="comment">     * - 如果删除结点只有一个儿子，将其子节点顶替其位置。</span></span><br><span class="line"><span class="comment">     * - 如果有两个非空子节点，则需要找出其后继节点。然后把后继节点替换到当前位置，并递归地删除后继节点。</span></span><br><span class="line"><span class="comment">     * 2. 通过“旋转和着色”来修正该树，使之重新成为一颗红黑树。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">RBNode</span> <span class="variable">t</span> <span class="operator">=</span> find(value);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果是双非空子节点，找到后继，并替换</span></span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">successor</span> <span class="operator">=</span> successor(t);</span><br><span class="line">            t.value = successor.value;</span><br><span class="line">            t = successor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RBNode</span> <span class="variable">replacement</span> <span class="operator">=</span> t.left != <span class="literal">null</span> ? t.left : t.right;</span><br><span class="line">        <span class="comment">//如果是单非空子节点，则直接删除替换</span></span><br><span class="line">        <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123;</span><br><span class="line">            replacement.parent = t.parent;</span><br><span class="line">            <span class="keyword">if</span> (t.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = replacement;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == t.parent.left) &#123;</span><br><span class="line">                t.parent.left = replacement;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.parent.right = replacement;</span><br><span class="line">            &#125;</span><br><span class="line">            t.parent = t.left = t.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//如果是双空结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.color == BLACK)</span><br><span class="line">                fixAfterDeletion(t);</span><br><span class="line">            <span class="keyword">if</span> (t.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t == t.parent.left)</span><br><span class="line">                    t.parent.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == t.parent.right)</span><br><span class="line">                    t.parent.right = <span class="literal">null</span>;</span><br><span class="line">                t.parent = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找后继结点</span></span><br><span class="line"><span class="comment">     * //在查找过程中，如果节点x右子树不为空，那么返回右子树的最小节点即可</span></span><br><span class="line"><span class="comment">     * //如果节点x的右子树为空，那么后继节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RBNode <span class="title function_">successor</span><span class="params">(RBNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">p</span> <span class="operator">=</span> node.right;</span><br><span class="line">            <span class="keyword">while</span> (p.left != <span class="literal">null</span>) p = p.left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">RBNode</span> <span class="variable">p</span> <span class="operator">=</span> node.parent;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; node == p.right) &#123;</span><br><span class="line">                node = p;</span><br><span class="line">                p = p.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本思路：</span></span><br><span class="line"><span class="comment">     * 删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</span></span><br><span class="line"><span class="comment">     * | Case 1| X是黑色结点，X的兄弟是红色结点，并且X的兄弟的子节点都是黑色节点|(01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。（无法从兄弟结点借调黑色结点，将兄弟结点上升，从兄弟结点的子节点借调，将其转换为Case 2,3,4）|</span></span><br><span class="line"><span class="comment">     * | Case 2| X是黑色结点，X的兄弟是黑色结点，并且X的兄弟的子节点都是黑色节点。|(01) 将x的兄弟节点设为“红色”。(02) 设当前结点为X的父节点。（把兄弟结点变红后，有可能导致祖父结点失去平衡，因此需要回溯到父节点进行调整。）|</span></span><br><span class="line"><span class="comment">     * | Case 3| X是黑色结点，X的兄弟是黑色结点，兄弟结点的左孩子是红色结点。|(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。（中间状态，借用侄子结点的红色，变成黑色来平衡查找树。）|</span></span><br><span class="line"><span class="comment">     * | Case 4| X是黑色结点，X的兄弟是黑色结点，兄弟结点的右孩子是红色结点。|(01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。（将兄弟结点的左黑色结点借调过来。）|</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(RBNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != root &amp;&amp; colorOf(node) == BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == leftOf(parentOf(node))) &#123;</span><br><span class="line">                <span class="type">RBNode</span> <span class="variable">sib</span> <span class="operator">=</span> rightOf(parentOf(node));</span><br><span class="line">                <span class="keyword">if</span>(colorOf(sib) == RED)&#123;</span><br><span class="line">                    setColor(sib,BLACK);</span><br><span class="line">                    setColor(parentOf(node),RED);</span><br><span class="line">                    leftRotate(parentOf(node));</span><br><span class="line">                    sib = rightOf(parentOf(node));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK)&#123;</span><br><span class="line">                    setColor(sib,RED);</span><br><span class="line">                    node = parentOf(node);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(colorOf(rightOf(sib)) == BLACK)&#123;</span><br><span class="line">                        setColor(leftOf(sib),BLACK);</span><br><span class="line">                        setColor(sib,RED);</span><br><span class="line">                        rightRotate(sib);</span><br><span class="line">                        sib = rightOf(parentOf(node));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(sib,colorOf(parentOf(node)));</span><br><span class="line">                    setColor(parentOf(node),BLACK);</span><br><span class="line">                    setColor(rightOf(sib),BLACK);</span><br><span class="line">                    leftRotate(parentOf(node));</span><br><span class="line">                    node = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RBNode</span> <span class="variable">sib</span> <span class="operator">=</span> leftOf(parentOf(node));</span><br><span class="line">                <span class="keyword">if</span>(colorOf(sib) == RED)&#123;</span><br><span class="line">                    setColor(sib,BLACK);</span><br><span class="line">                    setColor(parentOf(node),RED);</span><br><span class="line">                    rightRotate(parentOf(node));</span><br><span class="line">                    sib = leftOf(parentOf(node));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK)&#123;</span><br><span class="line">                    setColor(sib,RED);</span><br><span class="line">                    node = parentOf(node);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(colorOf(leftOf(sib)) == BLACK)&#123;</span><br><span class="line">                        setColor(rightOf(sib),BLACK);</span><br><span class="line">                        setColor(sib,RED);</span><br><span class="line">                        leftRotate(sib);</span><br><span class="line">                        sib = leftOf(parentOf(node));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(sib,colorOf(parentOf(node)));</span><br><span class="line">                    setColor(parentOf(node),BLACK);</span><br><span class="line">                    setColor(leftOf(sib),BLACK);</span><br><span class="line">                    rightRotate(parentOf(node));</span><br><span class="line">                    node = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        preOrderHelper(<span class="built_in">this</span>.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrderHelper</span><span class="params">(RBNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;(&quot;</span> + node.value.toString() + <span class="string">&quot;,&quot;</span> + colorName(colorOf(node)) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        preOrderHelper(node.left);</span><br><span class="line">        preOrderHelper(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        midOrderHelper(<span class="built_in">this</span>.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midOrderHelper</span><span class="params">(RBNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        midOrderHelper(node.left);</span><br><span class="line">        System.out.print(<span class="string">&quot;(&quot;</span> + node.value.toString() + <span class="string">&quot;,&quot;</span> + colorName(colorOf(node)) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        midOrderHelper(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">colorOf</span><span class="params">(RBNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span> ? BLACK : p.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RBNode <span class="title function_">parentOf</span><span class="params">(RBNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span> : p.parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(RBNode p, <span class="type">boolean</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>)</span><br><span class="line">            p.color = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RBNode <span class="title function_">leftOf</span><span class="params">(RBNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span>) ? <span class="literal">null</span> : p.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RBNode <span class="title function_">rightOf</span><span class="params">(RBNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span>) ? <span class="literal">null</span> : p.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">colorName</span><span class="params">(<span class="type">boolean</span> color)</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">color</span> <span class="operator">=</span>= RED ? <span class="string">&quot;RED&quot;</span> : <span class="string">&quot;BLACK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Integer[] test = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        RBTree&lt;Integer&gt; rbTree = <span class="keyword">new</span> <span class="title class_">RBTree</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer integer: test) rbTree.insert(integer);</span><br><span class="line">        rbTree.delete(<span class="number">4</span>);</span><br><span class="line">        rbTree.preOrder();</span><br><span class="line">        rbTree.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>参考链接：</strong></em><br><em><a href="http://tech.meituan.com/redblack-tree.html">红黑树深入剖析及Java实现</a></em><br><em><a href="http://www.importnew.com/21818.html">史上最清晰的红黑树讲解（上）</a></em><br><em><a href="http://www.importnew.com/21822.html">史上最清晰的红黑树讲解（下）</a></em><br><em><a href="http://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a></em></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;红黑树定义&quot;&gt;&lt;a href=&quot;#红黑树定义&quot; class=&quot;headerlink&quot; title=&quot;红黑树定义&quot;&gt;&lt;/a&gt;红黑树定义&lt;/h4&gt;&lt;p&gt;红黑树一种特殊的二叉查找树，在多种语言的多种数据结构中都有实现，查询效率较高。其特性是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点或者黑色，或者是红色。&lt;/li&gt;
&lt;li&gt;根节点是黑色。&lt;/li&gt;
&lt;li&gt;每个叶子结点（NIL）是黑色。&lt;/li&gt;
&lt;li&gt;如果一个结点是红色，它的子节点必须是黑色。&lt;/li&gt;
&lt;li&gt;从一个结点到该节点的子孙叶子结点的所有路径上包含相同数目的黑色结点。（确保没有一条路径会比其他路径长出两倍，接近于平衡二叉树。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;![Alt text](&amp;#x2F;images&amp;#x2F;Red-Black Tree&amp;#x2F;1490578618842.png)&lt;/p&gt;
&lt;h4 id=&quot;红黑树的时间复杂度&quot;&gt;&lt;a href=&quot;#红黑树的时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;红黑树的时间复杂度&quot;&gt;&lt;/a&gt;红黑树的时间复杂度&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;定理：一棵含有n个结点的红黑树的高度之多为$2log(n+1)$&lt;/strong&gt;&lt;br&gt;可以通过证明：高度为h的红黑树，他的包含的内节点的个数至少为$2^{h&amp;#x2F;2}-1$个。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithms" scheme="https://zhangfei614.github.io/categories/Algorithms/"/>
    
    
    <category term="Algorithms" scheme="https://zhangfei614.github.io/tags/Algorithms/"/>
    
    <category term="R-B Tree" scheme="https://zhangfei614.github.io/tags/R-B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题总结</title>
    <link href="https://zhangfei614.github.io/2017/06/13/Offer-Algorithms-Summary/"/>
    <id>https://zhangfei614.github.io/2017/06/13/Offer-Algorithms-Summary/</id>
    <published>2017-06-13T06:19:15.000Z</published>
    <updated>2022-05-28T15:06:45.952Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试3-二维数组中的查找"><a href="#面试3-二维数组中的查找" class="headerlink" title="面试3 二维数组中的查找"></a>面试3 二维数组中的查找</h4><p>二维数组中，从左到右，从上到下都是有序的，查找一个数是否存在。<br><strong>思路：</strong></p><ol><li>从右上角向左开始搜索，删除右侧的列，直到遇到比目标值小的数。</li><li>从右上角向下开始搜索，删除上方的行，直到遇到比目标值大的数。<br><strong>代码</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">find</span> <span class="params">(<span class="type">int</span>[][] board,<span class="type">int</span> rows,<span class="type">int</span> columns,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, column = columns - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(board[row][column] == key)&#123;</span><br><span class="line">found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//右上角-&gt;左搜索，删除右侧列</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[row][column] &gt; key)&#123;</span><br><span class="line">column --;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//右上角-&gt;下搜索，删除上侧行</span></span><br><span class="line">row ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span></li></ol><h4 id="面试8-旋转数组中的最小数"><a href="#面试8-旋转数组中的最小数" class="headerlink" title="面试8 旋转数组中的最小数"></a>面试8 旋转数组中的最小数</h4><p>把一个数组的最开始的若干个元素放到最后，成为一旋转数组。给定一个递增数组的旋转数组，求该数组中的最小值。<br><strong>思路：</strong><br>分别用index1表示前面子数组的第一个元素，index2表示后面子数组的最后一个元素。</p><ol><li>如果是旋转数组，则arr[index1] &gt;&#x3D; arr[index2]，否则直接返回。</li><li>如果arr[mid] &gt;&#x3D; arr[index1]，则说明mid在前面的递增数组中，则可以将index1&#x3D;mid。</li><li>如果arr[mid] &lt;&#x3D; arr[index2]，则说明mid在后面的递增数组中，则可以将index2&#x3D;mid。</li><li>考虑特殊情况：arr[mid]&#x3D;arr[index1]&#x3D;arr[index2]，则无法确定在哪个数组中；例如{1,0,1,1,1}的情况或者{1,1,1,0,1}的情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span>[] rArr)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rArr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>,index2 = n-<span class="number">1</span>, mid = index1;</span><br><span class="line"><span class="keyword">while</span>(rArr[index1] &gt;= rArr[index2])&#123;</span><br><span class="line"><span class="comment">//如果差1，则找到结果</span></span><br><span class="line"><span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>)&#123;</span><br><span class="line">mid = index2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mid = index1 + (index2 - index1)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//如果相等，则无法判断，只能顺序查找</span></span><br><span class="line"><span class="keyword">if</span>(rArr[mid] == rArr[index1] &amp;&amp; rArr[mid] == rArr[index2])&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> rArr[index1];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index1 + <span class="number">1</span>; i &lt;= index2; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(rArr[i] &lt; result)&#123;</span><br><span class="line">result = rArr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="comment">//如果大于rArr[index1]，则说明在后面</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(rArr[mid] &gt;= rArr[index1])&#123;</span><br><span class="line">index1 = mid;</span><br><span class="line"><span class="comment">//如果小于rArr[index2]，则说明在前面</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(rArr[mid] &lt;= rArr[index2])&#123;</span><br><span class="line">index2 = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rArr[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试10-二进制中1的个数"><a href="#面试10-二进制中1的个数" class="headerlink" title="面试10 二进制中1的个数"></a>面试10 二进制中1的个数</h4><p>求一个整数中1的个数<br><strong>思路1</strong><br>求32次，但是注意不能使用n&gt;&gt;1来判断循环是否结束（如果是负数，则符号位一直未1），而是利用flag&lt;&lt;1来判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitCount</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">unsigned <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; flag) count++;</span><br><span class="line">flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2</strong><br>当一个数n与n-1相与时，就将包括最后一位1的位全部之0，例如：1101 &amp; 1100 -&gt; 1100 ， 1010 &amp; 1001 -&gt; 1000，所以利用此种方案有多少1，则执行多少次循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitCount</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">count ++;</span><br><span class="line">n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展：</strong><br>两个整数m、n，m经过多少次位变换可以得到n：现将m、n异或，然后求异或值1的个数。<br>利用&amp;1来判断是否是级数，右移来表示除以2</p><h4 id="面试14-调整数组使所有奇数位于偶数前面"><a href="#面试14-调整数组使所有奇数位于偶数前面" class="headerlink" title="面试14 调整数组使所有奇数位于偶数前面"></a>面试14 调整数组使所有奇数位于偶数前面</h4><p>输入一个整数数组，将所有的奇数位于前半部分，偶数位于后半部分。<br><strong>思路：</strong><br>利用快速排序中的partition的思路，进行一次交换O(n)的扫描，并交换。<br><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">partitionArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((array[i] &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            start++;</span><br><span class="line">            exchange(array, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exchange(array, start, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试15-输入一个链表的倒数第k个节点"><a href="#面试15-输入一个链表的倒数第k个节点" class="headerlink" title="面试15 输入一个链表的倒数第k个节点"></a>面试15 输入一个链表的倒数第k个节点</h4><p>给定一个单向链表，输出该链表的倒数第k个节点。<br><strong>思路：</strong></p><ol><li>如果空间复杂度允许，则可以使用栈，但肯定不是最优解。</li><li>维护两个指针，当第一个指针走到k时，第二个指针开始走。<br><strong>代码：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">lastK</span><span class="params">(ListNode head,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head, q = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(count &gt;= k)&#123;</span><br><span class="line">q = q == <span class="literal">null</span> ? head : q.next;</span><br><span class="line">&#125;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>拓展：</strong></li></ol><ul><li>求链表的中间节点，快指针每一次走两步，慢指针每一次走一步，则最后为中间节点。</li><li>求链表中是否存在一个环，则同样使用两个指针，一个快指针，一个慢指针。</li></ul><h4 id="面试22-判断一个序列是否为另一个序列的出栈序列"><a href="#面试22-判断一个序列是否为另一个序列的出栈序列" class="headerlink" title="面试22 判断一个序列是否为另一个序列的出栈序列"></a>面试22 判断一个序列是否为另一个序列的出栈序列</h4><p>输入两个整数序列，第一个序列为入栈的序列，判断第二个序列是否为第一个序列合法的出栈序列。<br><strong>思路</strong></p><ol><li>如果栈顶元素不为当前出栈元素，则顺序遍历输入序列，将当前元素之前的元素都入栈。如果无法找到该元素，则输出错我</li><li>如果栈顶元素为当前元素，或者栈为空，则直接出栈或执行下一个元素。<br><strong>代码</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStackOut</span><span class="params">(<span class="type">int</span>[] in, <span class="type">int</span>[] out)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (in.length != out.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; j &lt; out.length; j++) &#123;</span><br><span class="line">           <span class="keyword">while</span> (stack.isEmpty() || stack.peek() != out[j]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i &gt;= in.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               stack.push(in[i++]);</span><br><span class="line">           &#125;</span><br><span class="line">           stack.pop();</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="面试26-复杂链表的复制"><a href="#面试26-复杂链表的复制" class="headerlink" title="面试26 复杂链表的复制"></a>面试26 复杂链表的复制</h4><p>如果一个链表内不仅含有next指针，还有一个random指针，请完成这个链表的深拷贝。<br><strong>思路1</strong><br>利用一个Hash表存储&lt;N,N’&gt;对，最后再通过映射的方法来完成所有复制。时间复杂度为O(n)，空间复杂度为O(N)<br><strong>思路2</strong></p><ol><li>将新建结点放到原有结点的后面。<br>![Alt text](&#x2F;images&#x2F;Offer Algorithms Summary&#x2F;1496650732120.png)</li><li>根据前一个结点的random指针，对后一个结点的random指针进行修改。<br>![Alt text](&#x2F;images&#x2F;Offer Algorithms Summary&#x2F;1496650770141.png)</li><li>拆分原来的大链表，使其变为两个链表。<br>![Alt text](&#x2F;images&#x2F;Offer Algorithms Summary&#x2F;1496651008444.png)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildNodes</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(p.val);</span><br><span class="line">q.next = p.next;</span><br><span class="line">p.next = q;</span><br><span class="line">p = q.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copyRandomPointer</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p.random != <span class="literal">null</span>)&#123;</span><br><span class="line">p.next.random = p.random.next;</span><br><span class="line">&#125;</span><br><span class="line">p = p.next.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">spiltList</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> node, q = node.next, newList = node.next;</span><br><span class="line"><span class="keyword">while</span>( p != <span class="literal">null</span>)&#123;</span><br><span class="line">p.next = q.next;</span><br><span class="line">p = p.next;</span><br><span class="line">q.next = p == <span class="literal">null</span> ? <span class="literal">null</span> : p.next;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">copyList</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">buildNodes(node);</span><br><span class="line">copyRandomPointer(node);</span><br><span class="line"><span class="keyword">return</span> spiltList(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="面试28-字符的全排序"><a href="#面试28-字符的全排序" class="headerlink" title="面试28 字符的全排序"></a>面试28 字符的全排序</h4><p>给出一个字符串，打印出这个字符串所有的排序。<br><strong>思路</strong></p><ol><li>将第一个字符与后面的字符依次进行交换。</li><li>然后对后面的字符递归调用全排序。</li><li>将字符交换回来。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Permutation</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    Permutation(chars, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Permutation</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin == chars.length - <span class="number">1</span> ) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(chars));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin ; i &lt; chars.length; i++) &#123;</span><br><span class="line">            exchagne(chars, begin, i);</span><br><span class="line">            Permutation(chars, begin + <span class="number">1</span>);</span><br><span class="line">            exchagne(chars, begin, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exchagne</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="面试29-数组中此时超过一半的数字"><a href="#面试29-数组中此时超过一半的数字" class="headerlink" title="面试29 数组中此时超过一半的数字"></a>面试29 数组中此时超过一半的数字</h4><p>给定一个输入数组，其中一个数字出现次数超过了数组长度的一半，求出该数。<br><strong>思路1</strong><br>利用Partition的思路，对数组进行划分，不断缩小搜索长度。</p><ol><li>如果返回index&#x3D;n&#x2F;2，则直接返回对应的数。</li><li>如果返回index&lt;n&#x2F;2，则继续搜索后面的子数组。</li><li>如果返回index&gt;n&#x2F;2，则继续搜索前面的子数组。</li></ol><p><strong>思路2</strong><br>因为其中一个数字出现次数比其他数字出现次数总和都多，因此遍历时可以保存上一个数字和出现次数。</p><ol><li>如果和上一个次数相同，则加1。</li><li>如果和上一个次数不同，则减1。</li><li>如果次数等于0，则更换上一个数字，并将次数重新置为1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">findHalfNumber</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">result = arr[i];</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == result)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//check whether the result is right number</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试32-从1到n整数中1出现的次数"><a href="#面试32-从1到n整数中1出现的次数" class="headerlink" title="面试32 从1到n整数中1出现的次数"></a>面试32 从1到n整数中1出现的次数</h4><p>输入一个整数n，求从1到n所有整数中1出现的次数。<br>思路：<br>递归求解，例如21345，可以分为两部分：1<del>1345,1346</del>21345来求解。<br>在求解过程中，可以一次求解：</p><ol><li>第一位为1的情况，即10000~19999中一的个数（如果第一位不为1）。</li><li>后面几位中为1的情况，可以固定一位，然后其他位任意去0~9</li><li>然后递归求解1~1245的情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOf1</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= chars.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> chars[begin] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (begin == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一位为1的所有数字</span></span><br><span class="line">    <span class="keyword">if</span> (first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result += (<span class="type">int</span>) Math.pow(<span class="number">10</span>, chars.length - begin - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first == <span class="number">1</span>) &#123;</span><br><span class="line">        result += Integer.valueOf(String.valueOf(chars, begin + <span class="number">1</span>, chars.length - begin - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1346~21345中，除了第一位为1的其他为为1的所有数字,固定某一位为1，其他为取值0~9</span></span><br><span class="line">    result += first * (chars.length - begin - <span class="number">1</span>) * (<span class="type">int</span>) Math.pow(<span class="number">10</span>, chars.length - begin - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//递归求解1~1345的个数</span></span><br><span class="line">    result += numberOf1(chars, begin + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试33-第n个丑数"><a href="#面试33-第n个丑数" class="headerlink" title="面试33 第n个丑数"></a>面试33 第n个丑数</h4><p>定义一个数的因子只要2,3,5的数称为丑数，求第n个丑数。<br><strong>思路</strong><br>第n个丑数肯定是由前n-1个丑数生成的，用三个指针分别指向生成下一个丑数的位置，然后计算最小值来生成丑数，然后更新指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] pointer = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">numbers[i] = Math.min(numbers[pointer[<span class="number">0</span>]]*<span class="number">2</span>,Math.min(numbers[pointer[<span class="number">1</span>]*<span class="number">3</span>],numbers[pointer[<span class="number">2</span>]*<span class="number">5</span>]));</span><br><span class="line"><span class="comment">//更新指针</span></span><br><span class="line">pointer[<span class="number">0</span>] = numbers[i] == pointer[<span class="number">0</span>]*<span class="number">2</span> ? pointer[<span class="number">0</span>]+<span class="number">1</span>:pointer[<span class="number">0</span>];</span><br><span class="line">pointer[<span class="number">1</span>] = numbers[i] == pointer[<span class="number">1</span>]*<span class="number">3</span> ? pointer[<span class="number">1</span>]+<span class="number">1</span>:pointer[<span class="number">1</span>];</span><br><span class="line">pointer[<span class="number">2</span>] = numbers[i] == pointer[<span class="number">2</span>]*<span class="number">5</span> ? pointer[<span class="number">2</span>]+<span class="number">1</span> : pointer[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试37-两个链表的第一个公共结点"><a href="#面试37-两个链表的第一个公共结点" class="headerlink" title="面试37 两个链表的第一个公共结点"></a>面试37 两个链表的第一个公共结点</h4><p>两个链表，找到第一个公共结点<br><strong>思路</strong><br>遍历一遍先求出两个链表的长度，然后让长的链表先走，最后在一起走。</p><h4 id="面试40-数组中只出现一次的数"><a href="#面试40-数组中只出现一次的数" class="headerlink" title="面试40 数组中只出现一次的数"></a>面试40 数组中只出现一次的数</h4><p>一个整形数组中除了两个数字之外，其它数字都出现了两次，找出这两个值出现一次的数字。<br><strong>思路</strong></p><ol><li>将数组中所有的数进行一次异或，获得的是两个只出现一次的数的异或。</li><li>找出这个异或结果的某一位的1取出来，作为划分数组的掩码，则两个数会分到不同的子数组。</li><li>然后对每个子数组进行一次异或，分别获得每个子数组的只出现一次的数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findNumbers(<span class="type">int</span>[] arr)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) data ^= arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((data &amp; mask) == <span class="number">0</span>) mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">                num1 ^= arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num2 ^= arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num1, num2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试41-打印和为n的序列和"><a href="#面试41-打印和为n的序列和" class="headerlink" title="面试41 打印和为n的序列和"></a>面试41 打印和为n的序列和</h4><p>给定n，打印序列1~n中和为n的所有连续子序列。<br><strong>思路</strong></p><ol><li>定义small和big用来存储序列最小值和序列最大值。</li><li>计算small到big的和，如果和为n，则打印序列。</li><li>如果和小于n则增大big。</li><li>如果和大于n则增大smll。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSequenceOfSum</span><span class="params">(<span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">1</span>, big = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (small &lt;= (sum + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> (small + big) * (big - small + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">            print(small, big);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt;= sum) &#123;</span><br><span class="line">            small++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            big++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试43-n个骰子和的概率分布"><a href="#面试43-n个骰子和的概率分布" class="headerlink" title="面试43 n个骰子和的概率分布"></a>面试43 n个骰子和的概率分布</h4><p>给定n个筛子，求所有和的情况的概率分布</p><p><strong>思路：</strong></p><ol><li>两个数组，第一个数组用于保存n-1个骰子时，各个和出现的次数；第二个数组用于保存n个骰子是，各个和出现的次数。</li><li>利用n-1,n-2,n-3,n-4,n-5,n-6来计算当前n的的次数。</li><li>交换两个数组，进行下一轮迭代。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printProbability</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span>[][] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][n * MAX_VALUE + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= MAX_VALUE; i++) count[flag][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//小于i的都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) count[<span class="number">1</span> - flag][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= i * MAX_VALUE; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= j &amp;&amp; k &lt;= MAX_VALUE; k++)</span><br><span class="line">                count[<span class="number">1</span> - flag][j] += count[flag][j - k];</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> Math.pow(MAX_VALUE, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt;= n * MAX_VALUE; i++) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d : % .6f\n&quot;</span>, i, count[flag][i] / total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;面试3-二维数组中的查找&quot;&gt;&lt;a href=&quot;#面试3-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;面试3 二维数组中的查找&quot;&gt;&lt;/a&gt;面试3 二维数组中的查找&lt;/h4&gt;&lt;p&gt;二维数组中，从左到右，从上到下都是有序的，查找一个数是否存在。&lt;br&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从右上角向左开始搜索，删除右侧的列，直到遇到比目标值小的数。&lt;/li&gt;
&lt;li&gt;从右上角向下开始搜索，删除上方的行，直到遇到比目标值大的数。&lt;br&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;[][] board,&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; rows,&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; columns,&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; key)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;type&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, column = columns - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(row &amp;lt; rows &amp;amp;&amp;amp; column &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[row][column] == key)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			found = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//右上角-&amp;gt;左搜索，删除右侧列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[row][column] &amp;gt; key)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			column --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//右上角-&amp;gt;下搜索，删除上侧行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			row ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; found;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Algorithms" scheme="https://zhangfei614.github.io/categories/Algorithms/"/>
    
    
    <category term="Algorithms" scheme="https://zhangfei614.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="https://zhangfei614.github.io/2017/03/14/Sort-Algorithms-Summary/"/>
    <id>https://zhangfei614.github.io/2017/03/14/Sort-Algorithms-Summary/</id>
    <published>2017-03-14T02:47:04.000Z</published>
    <updated>2022-05-28T15:06:45.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h3><h4 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h4><p><strong>思路</strong>：<br>　每次选择最小的元素与第i个元素进行交换<br><strong>特点</strong>：</p><ul><li>运行时间与输入无关，即使输入数据主键相同或有序，时间仍和最差相同，时间复杂度为 $N^2$</li><li>数据移动最少，仅需要$N$次交换</li><li>在第i次，会进行1次exchange和 $N-i-1$ 次比较，总的比较次数为$N(N-1)&#x2F;2$次</li><li>该算法为不稳定算法，因为有可能将</li></ul><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//从第i+1个开始寻找最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        SortUtils.exchane(arr, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h4><p><strong>思路</strong><br>　将第i个元素插入到前面有序元素中合适的位置<br><strong>特点</strong></p><ul><li>最好情况下，即已经有序，则需要$N-1$次比较，$N$次移动</li><li>最差情况下，即完全逆序，需要$N^2$次比较和$N^2$次交换</li><li>平均情况下，需要$1&#x2F;4<em>N^2$次比较和$1&#x2F;4</em>N^2$次交换</li><li>交换次数和倒置数相同，需要就比较次数大于倒置数量，小于等于倒置的数量加上数组的大小再减一</li></ul><p><em><strong>倒置：</strong></em>数组中两个顺序颠倒的元素(可重复计数)</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//从i-1个开始交换，直至到正确的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j + <span class="number">1</span>] &lt; arr[j]; j--)</span><br><span class="line">            SortUtils.exchane(arr, j + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="折半查找插入排序（BinaryInsertionSort"><a href="#折半查找插入排序（BinaryInsertionSort" class="headerlink" title="折半查找插入排序（BinaryInsertionSort)"></a>折半查找插入排序（BinaryInsertionSort)</h4><p><strong>思路</strong><br>在查找第i个元素在前面有序元素的位置时，采用二分查找的策略。<br><strong>特点：</strong></p><ul><li>最差情况下，也是需要$N^2$的时间复杂度。</li><li>最好情况下，需要$O(nlgn)$的时间复杂度。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">//查询需要插入的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(arr, <span class="number">0</span>, i - <span class="number">1</span>, key);</span><br><span class="line">        <span class="comment">//移动数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= index; j--) arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[index] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i, high = j, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h4><p><strong>思路</strong><br>　选取一个序列作为步长，然后通过大步长排序将元素移动到较远的地方（原始插入排序为一步步移动），从而使数组局部有序，最终再利用插入排序进行全局排序。<br><strong>特点</strong></p><ul><li>算法性能也取决于步长数组的选取</li><li>在最坏的情况下，算法的复杂度和$N^{3&#x2F;2}$</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//不断缩小step直至为1</span></span><br><span class="line">       <span class="keyword">while</span> (step &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//对每一组进行排序，一共step组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">               <span class="comment">//对每一组从第二个开始插入排序</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + step; j &lt; n; j += step) &#123;</span><br><span class="line">                   <span class="comment">//一直交换到合适的位置</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j - step; k &gt;= <span class="number">0</span> &amp;&amp; arr[k + step] &lt; arr[k]; k -= step)</span><br><span class="line">                       SortUtils.exchange(arr, k + step, k);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           step = step / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>思路</strong><br>每一次冒泡过程两两比较，如果发生逆序，则进行交换。总共需要n-1次冒泡，地k次冒泡需要比较n-k次。<br><strong>特点</strong></p><ul><li>时间复杂度为$O(N^2)$，空间复杂度为$O(1)$</li><li>可以使用一个标志位，如果没有产生交换，则直接返回。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">//冒泡n-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//改进，如果当前次已经没有冒泡，则直接返回</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//每次冒出一个最大值到最后边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//交换相邻位置的</span></span><br><span class="line">                    SortUtils.exchange(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>思路</strong><br>　选取一个切分元素，将原始元素按照此标准进行切分为两个子数组，分别对子数组进行排序。快速排序和归并排序区别：归并排序是在递归后对数组进行操作，而快速排序则在递归钱对数组进行操作。<br><strong>简单的切分</strong><br>    选取切分元key，索引i，j分别为序列开始，索引j不断后移，当遇到a[j]&lt;&#x3D;key时，则交换a[j]和a[i+1]，最后交换a[i]和key。这样索引i的左侧都为&lt;&#x3D;key，右侧都为&gt;key。<br>![Alt text](&#x2F;images&#x2F;Sort Algorithms Summary&#x2F;1489046415296.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">simplePartition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">//默认选取第一个元素为切分元</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="comment">//j后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start + <span class="number">1</span>; j &lt;= end; j++) &#123;</span><br><span class="line">        <span class="comment">//遇到小于切分元的key，则交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= key)</span><br><span class="line">            SortUtils.exchange(arr, ++i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtils.exchange(arr, i, start);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双工切分</strong><br>　选定a[lo]作为切分元素，使用指针i从左向右扫描比切分元素大的元素，指针j从右向左扫描比切分元素小的元素，交换两个元素的位置，重复上述过程，直至i和j相等，最后将a[lo]和a[j]交换，并返回j的索引。这种方法比上述方法交换次数较少。<br>![Alt text](&#x2F;images&#x2F;Sort Algorithms Summary&#x2F;1489050265957.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">twoWayPartition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">//默认选择第一个元素为切分元</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>, j = end;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="comment">//向右寻找大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= key) ++i;</span><br><span class="line">        <span class="comment">//向左寻找小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[j] &gt;= key) --j;</span><br><span class="line">        <span class="comment">//交换元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            SortUtils.exchange(arr, i, j);</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将切分元移到中间</span></span><br><span class="line">    SortUtils.exchange(arr, start, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>半双工切分</strong><br>    与上述类似，但每次扫描完一边时就赋值数据，不需要交换数据。<br>![Alt text](&#x2F;images&#x2F;Sort Algorithms Summary&#x2F;1489051255182.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">oneWayPartition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">//向左寻找最小元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= key) j--;</span><br><span class="line">        <span class="comment">//覆盖元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) arr[i++] = arr[j];</span><br><span class="line">        <span class="comment">//向右寻找最大元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= key) i++;</span><br><span class="line">        <span class="comment">//覆盖元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) arr[j--] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = key;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　<br><strong>特点</strong></p><ul><li>将长度为Ｎ的无重复数组进行排序，快速排序平均需要～$N<em>lnN$此比较和$1&#x2F;6N</em>lnN$次数据交换。</li><li>快速排序最多需要约为$N^2&#x2F;2$次比较，此时就退化为冒泡排序。</li></ul><p><strong>优化</strong></p><ul><li>将小数组切换到插入排序</li><li>三取样排序，选取三个样本，基本为a[0],a[mid],a[high]三个，并选取中间数作为切分元素。</li><li>随机划分元，将最右边的元素与数组的随机一个元素进行交换，防止运行时间不依赖于输入序列的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">//选取随机元素索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    SortUtils.exchange(arr, start, randomIndex);</span><br><span class="line">    <span class="keyword">return</span> simplePartition(arr, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用算法导论上的算法，选取中位数。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//划分数组</span></span><br><span class="line"><span class="comment">//        int index = simplePartition(arr, start, end);</span></span><br><span class="line"><span class="comment">//        int index = twoWayPartition(arr, start, end);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> randomPartition(arr, start, end);</span><br><span class="line">        <span class="comment">//递归排序</span></span><br><span class="line">        sort(arr, start, index - <span class="number">1</span>);</span><br><span class="line">        sort(arr, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h5><p><strong>思路</strong><br>　先将数组的两个子数组进行排序，然后进行归并。采用递归的思想，即不断递归左子数组，使其有序，再递归右子数组。<br><strong>特点</strong></p><ul><li>对于长度为$N$的任意数组，自顶向下的归并排序需要$1&#x2F;2<em>N</em>lgN$（最好情况，左数组最大值比右数组最小值小）至$NlgN$（最坏情况，左数组和右数组交叉排序）次比较。证明思路：$C(2^n)&#x3D;2C(2^{n-1})+ 2^n$&#x3D;&#x3D;&gt;$C(2^n)&#x2F;2^n&#x3D;C(2^{n-1})&#x2F;2^{n-1}+ 1$&#x3D;&#x3D;&gt;$C(2^n)&#x2F;2^n&#x3D;C(2^0)&#x2F;2^0+ n$&#x3D;&#x3D;&gt;$C(N)&#x3D;C(2^n)&#x3D;n2^n&#x3D;NlgN$</li><li>对于长度为$N$的任意数组，自顶向下的归并排序需要$6<em>N</em>lgN$次比较，其中2N次复制，2N次移动回去，2N次比较时访问</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个临时数组</span></span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左侧数组排序</span></span><br><span class="line">    sort(arr, start, mid, temp);</span><br><span class="line">    <span class="comment">//右侧数组排序</span></span><br><span class="line">    sort(arr, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    merge(arr, start, mid, end, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = mid + <span class="number">1</span>, k = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= end) temp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">//复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        arr[k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h5><p><strong>思路</strong><br>　先对微型数组归并，例如相邻的元素，在得到子数组。此时不需要采用递归。例如2&#x3D;&#x3D;&gt;4&#x3D;&#x3D;&gt;8&#x3D;&#x3D;&gt;…的思路<br><strong>特点</strong></p><ul><li>自底向上的归并排序，其比较次数和访问数组次数都相同。但可以节省调用方法的时间</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">downToUpSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">//从最低的1开始，依次向上归并，每次步长为上次的2倍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>; step &lt; n; step += step) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>; low &lt; n - step; low += (step * <span class="number">2</span>))</span><br><span class="line">            merge(arr, low, low + step - <span class="number">1</span>, Math.min(low + step * <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>), temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><ul><li>对小规模子数组采用插入排序</li><li>不将元素复制到辅助数组，采用角色互换的方法，减少一次复制的过程</li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>相关概念</strong><br>    堆有序：当一颗二叉树的每个节点都大于等于它的子节点时，它被称为堆有序。<br>    上浮：因为一个节点比其父节点大而产生无序状态，需交换该节点与父节点的位置。将新元素插入到数组末尾，然后增加堆的大小，再让该元素上浮到合适的位置。<br>　下沉：因为一个节点比其子节点小而产生无序状态，需交换该节点与子节点中较大的位置。删除头部元素，再让数组末端元素放到顶端，减小堆的大小，让该元素下沉到合适位置。<br><strong>思路</strong><br>   将待排序元素构造成一个大顶堆，每次将堆顶元素和最后一个元素互换，然后再维护前n-1个元素形成大顶堆。<br><strong>特点</strong></p><ul><li>建堆的复杂度政委$O(n)$，每一次调整堆的复杂度为$O(lgN)$，因此总的复杂小于$O(n) + O(nlgn)$</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">//调整所有非叶子结点，形成最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        adjustHeap(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//取出堆顶元素到最后</span></span><br><span class="line">        SortUtils.exchange(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">//调整前面的元素仍称为最大堆</span></span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dad</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">son</span> <span class="operator">=</span> dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123;</span><br><span class="line">        <span class="comment">//选中son中较大的结点</span></span><br><span class="line">        <span class="keyword">if</span> (son &lt; end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) ++son;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &lt; arr[son]) &#123;</span><br><span class="line">            <span class="comment">//dad小于son则调整</span></span><br><span class="line">            SortUtils.exchange(arr, dad, son);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不需要调整，则直接退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><ul><li>多叉堆：对于完全三叉树，数组对应索引需要进行修改。父节点为k&#x2F;3，子节点为3k-1,3k,3k+1</li><li>调整数组大小：不采用固定数组大小的模式，而是采用前面实现栈的方式，动态调整数组大小。</li></ul><h3 id="其它排序"><a href="#其它排序" class="headerlink" title="其它排序"></a>其它排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><strong>思路</strong><br>建立一个排序序列取值范围大小的数组C，然后根据C的下标，统计序列中每个元素出现的次数，然后累加每个元素之前元素的个数到该元素所在C中。最后根据C得到最后的排序序列。<br><strong>特点</strong><br>计数排序的限制（待排序序列的取值范围为k）：T(n) &#x3D; (n + k)，</p><ul><li>如果k &lt; n，T(n)  &#x3D; O(n);</li><li>否则，如果k &lt; nlgn，T(n) &#x3D; O(nlgn);</li><li>否则，如果k &gt; n^2，T(n) &#x3D; O(n^2);</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= max; i++) count[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) count[arr[i]]++;</span><br><span class="line">    <span class="comment">//累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) count[i + <span class="number">1</span>] += count[i];</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        count[arr[i]]--;</span><br><span class="line">        temp[count[arr[i]]] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制回原数组</span></span><br><span class="line">    System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><strong>思路</strong></p><ol><li>将所有数的取值范围均匀划分成M个桶。</li><li>将N个元素分不到各个桶当中去。</li><li>对每个桶进行排序。</li><li>再依次将各个桶内元素取出，即为有序的序列。<br>![Alt text](&#x2F;images&#x2F;Sort Algorithms Summary&#x2F;1489110832115.png)<br><strong>特点</strong><br>时间复杂度为$O(N+C)$，$O(C)&#x3D;O(M(N&#x2F;M)log(N&#x2F;M))&#x3D;O(NlogN-NlogM)$，空间复杂度为$O(N+M)$，算法是稳定的，且与初始序列无关。</li></ol><h3 id="各类算法复杂度汇总"><a href="#各类算法复杂度汇总" class="headerlink" title="各类算法复杂度汇总"></a>各类算法复杂度汇总</h3><p>![Alt text](&#x2F;images&#x2F;Sort Algorithms Summary&#x2F;1489115690357.png)<br><em><strong>参考链接</strong></em><br><a href="https://segmentfault.com/a/1190000004994003#articleHeader40">排序算法总结</a><br><a href="http://blog.csdn.net/anonymalias/article/details/11547039"> 面试算法之排序算法集锦</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;比较排序&quot;&gt;&lt;a href=&quot;#比较排序&quot; class=&quot;headerlink&quot; title=&quot;比较排序&quot;&gt;&lt;/a&gt;比较排序&lt;/h3&gt;&lt;h4 id=&quot;选择排序-Selection-Sort&quot;&gt;&lt;a href=&quot;#选择排序-Selection-Sort&quot; class=&quot;headerlink&quot; title=&quot;选择排序(Selection Sort)&quot;&gt;&lt;/a&gt;选择排序(Selection Sort)&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：&lt;br&gt;　每次选择最小的元素与第i个元素进行交换&lt;br&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时间与输入无关，即使输入数据主键相同或有序，时间仍和最差相同，时间复杂度为 $N^2$&lt;/li&gt;
&lt;li&gt;数据移动最少，仅需要$N$次交换&lt;/li&gt;
&lt;li&gt;在第i次，会进行1次exchange和 $N-i-1$ 次比较，总的比较次数为$N(N-1)&amp;#x2F;2$次&lt;/li&gt;
&lt;li&gt;该算法为不稳定算法，因为有可能将&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; arr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//从第i+1个开始寻找最小值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; n; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr[j] &amp;lt; arr[min]) min = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SortUtils.exchane(arr, i, min);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Algorithms" scheme="https://zhangfei614.github.io/categories/Algorithms/"/>
    
    
    <category term="Sort" scheme="https://zhangfei614.github.io/tags/Sort/"/>
    
    <category term="Algorithms" scheme="https://zhangfei614.github.io/tags/Algorithms/"/>
    
  </entry>
  
</feed>
