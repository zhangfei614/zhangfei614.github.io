{"pages":[{"title":"Know About Me?","text":"I will tell you later …","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"WIP:《深度学习之PyTorch物体检测实战》笔记","text":"基础知识Tensor: grad: 对应梯度，类型为Tensor，维度相同。 grad_fn: 指向的function对象，经历了怎样的操作。 backword()： 动态图特性，每次前向传播从头开始构建计算图。 grac_variables，根节点导数==根节点权重系数。 retain_graph，多个输出反向求导设置为True。 torch.nn: nn.Module:神经网络类。 nn.Parameter:默认需要求导的参数。 forward():定义类的前向传播。 nn.functional:不需要进行参数学习的层。 nn.Sequential():快速搭建模型各层。 nn.optim: 优化算法，SGD，Adam，Adagrad等 神经网络基本组成： 卷积层：提取数据特征，根据卷积核扫描矩阵。 激活函数：非线性函数表达复杂空间。 sigmod: 适合二分类，计算量大，梯度小时。 ReLU：计算简短，收敛快，但负区域输入值都为0。 Leaky ReLU: 负区域赋予很小的权重。 softmax：多分类使用。 池化层：降低特征图的参数量，提升计算速度，增加感受野，比如：Max Pooling，Average Pooling。 Dropout层： 参数过多而训练样本较少，模型容易产生过拟合现象。 在训练时，每个神经元以概率p保留，即以概率 1-p 的概率停止工作。","link":"/2021/08/12/pytorch-detection-reading-note/"},{"title":"WIP:seldon-core简介","text":"部署minikube &amp; istio &amp; seldon-core1234567891011121314151617181920212223242526272829303132333435363738394041#安装istio #更改istio为NodePort方式 kubectl patch service istio-ingressgateway -n istio-system -p '{&quot;spec&quot;:{&quot;type&quot;:&quot;NodePort&quot;}}'#tmux开启istio-ingressgateway的port-forwardkubectl port-forward -n istio-system --address 0.0.0.0 service/istio-ingressgateway 7080:80#安装seldon-core#创建namespacekubectl create namespace seldon-system#安装使用istio的seldon-corehelm install seldon-core seldon-core-operator \\ --repo https://storage.googleapis.com/seldon-charts \\ --set usageMetrics.enabled=true \\ --namespace seldon-system \\ --set istio.enabled=true#部署模型kubectl create namespace seldonkubectl apply -f - &lt;&lt; ENDapiVersion: machinelearning.seldon.io/v1kind: SeldonDeploymentmetadata: name: iris-model namespace: seldonspec: name: iris predictors: - graph: implementation: SKLEARN_SERVER modelUri: gs://seldon-models/v1.10.0-dev/sklearn/iris name: classifier name: default replicas: 1END#访问http://10.122.101.60:7080/seldon/seldon/iris-model/api/v1.0/doc/#/ 参考链接istio 1.8.2安装及可观测性配置","link":"/2021/08/16/seldon-core-intro/"},{"title":"我眼中的MLOps","text":"序 问题背景 什么是MLOps？ 元素、角色、流程 名词对比 开源实现 部署相关 Core工具链对比 旷视的MLOps？ 复杂背景 IPU在做啥？ 全流程？ MLOps-Sig 终 序MLOps这个概念最近比较流行，晨光也发了一些Link给大家参考。之前在做Saver和介绍ModelServing的过程中，查过一些资料，可以整理一下供大家参考。MLOps涵盖的概念比较多，我也是不求甚解，有兴趣可以多了解一些，对于IPU可以在公司内MLOps上做什么也可以多讨论。 问题背景大部分介绍MLOps的文章都会引用这张图，出自Google的一篇论文：Hidden Technical Debt in Machine Learning Systems核心内容： 利用机器学习解决问题的完整系统，关于模型训练的代码其实只占很少一部分。 为了系统中各个模块合作，各类“胶水代码”会有很多反模式设计，很难维护，留下很多隐藏的“技术债”。 参考链接： Hidden Technical Debt in Machine Learning Systems 阅读笔记 Why you Might Want to use Machine Learning 什么是MLOps？from MLOps Principles 顾名思义，MLOps就是机器学习时代的DevOps。它的主要作用就是连接模型构建团队和业务，运维团队，建立起一个标准化的模型开发，部署与运维流程，使得企业组织能更好的利用机器学习的能力来促进业务增长。 from 从小作坊到智能中枢: MLOps简介 元素、角色、流程MLOps与传统Devops最大不同是管理的最基本要素从Code，扩充到了Data&amp;Model&amp;Code，而这三者之间的相互流转一般会牵扯到不同角色。如何利用自动化工具打破角色、组织之前的边界，可持续的交付机器学习能力到用户侧是MLOps要解决的问题。 元素：角色：流程from Continuous Delivery for Machine Learning 名词对比 DevOps 更快地交付软件一系列旨在消除开发和运维团队之间障碍的实践，以便更快地构建和部署软件。它通常会被工程团队所采用，包括 DevOps 工程师、基础设施工程师、软件工程师、站点可靠性工程师和数据工程师。DataOps 更快地交付数据一系列旨在提高数据分析质量并缩短分析周期的实践。DataOps 的主要任务包括数据标记、数据测试、数据管道编排、数据版本控制和数据监控。分析和大数据团队是 DataOps 的主要操作者，但是任何生成和使用数据的人都应该采用良好的 DataOps 实践。这包括数据分析师、BI 分析师、数据科学家、数据工程师，有时还包括软件工程师。MLOps 更快地交付机器学习模型一系列设计、构建和管理可重现、可测试和可持续的基于 ML 的软件实践。对于大数据 / 机器学习团队，MLOps 包含了大多数 DataOps 的任务以及其他特定于 ML 的任务，例如模型版本控制、测试、验证和监控。AIOps 利用 AI 的功能增强了 DevOps 工具有时人们错误地将 MLOps 称为 AIOps，但它们是完全不同的。以下说明来自 Gartner（高德纳，美国咨询公司）：AIOps 平台利用大数据、现代机器学习以及其他先进的分析技术，直接或间接地增强 IT 运维（监控、自动化和服务台），具有前瞻性、个性化以及动态的洞察力。因此，AIOps 通常是利用 AI 技术来增强服务产品的 DevOps 工具。AWS Cloud Watch 提供的报警和异常检测是 AIOps 的一个很好的例子。 from What the Ops are you talking about? MLOps概念参考链接 https://ml-ops.org/ https://en.wikipedia.org/wiki/MLOps MLOps：机器学习中的持续交付和自动化流水线 Google将MLOps流水线按照自动化程度分了3个Level，可以参考。 Machine learning operations (MLOps) Resource Center from Azure 吴恩达：从以模型为中心到以数据为中心的AI 吴恩达同时也有一门关于MLOps的课程，讲解如何E2E训练、部署、监控模型。 开源实现MLOps这个概念说实在的，其实是一个大杂烩，涵盖机器学习全链路的所有工具链。但一般来说，讨论MLOps，可能有主要这两个方向： 规范流：和DevOps类似，MLOps并不具体指某个单一的系统，而是强调各组织之间合作的规范性。这一部分比较虚，可以参考MLOps设计的一些基本原则和技术选型指导。 平台流：在MLOps这个方向，已经有很多开源或者创业团队在做，很多实现了一个统一的平台入口，进行数据、模型、部署的管理。 在这里简单分享几个MLOps平台案例：Kubeflow The Kubeflow project is dedicated to making deployments of machine learning (ML) workflows on Kubernetes simple, portable and scalable. Our goal is not to recreate other services, but to provide a straightforward way to deploy best-of-breed open-source systems for ML to diverse infrastructures. Anywhere you are running Kubernetes, you should be able to run Kubeflow. 以Google为首，目前star数最多，影响比较大的MLOps的云原生平台。 在k8s云原生基础上，集成必要的开源组件，来管理模型开发的流程。 以Operator为核心，来管理不同训练架构在k8s上执行的训练Job。 ClearML ClearML is a ML/DL development and production suite, it contains FOUR main modules: Experiment Manager - Automagical experiment tracking, environments and results MLOps - Orchestration, Automation &amp; Pipelines solution for ML/DL jobs (K8s / Cloud / bare-metal) Data-Management - Fully differentiable data management &amp; version control solution on top of object-storage (S3 / GS / Azure / NAS) NEW 🔥 Model-Serving 🎉 - cloud-ready Scalable model serving solution!✨ Deploy new model endpoints in under 5 minutes ✨💪 includes optimized GPU serving support backed by Nvidia-Triton 🦾📊 with out-of-the-box Model Monitoring 😱 看起来不错的开源创业公司，做了实验管理、任务执行、模型服务等模块。 公司内的Kubebrain貌似尝试接入过ClearML，参考Kubebrain接入ClearML方案？ MLOps平台列举 Global MLOps and ML tools landscape Top 10 Open Source MLOps Tools MLOps: 数据编程时代的工具链创业机会 部署相关在MLOps流程里的最后阶段: Model Serving/Deployment是可以单独拿出来聊一下的，因为这一部分其实和Core的同学应该最为密切了。从模型PPL搭建，封装微服务，部署到目标集群，这些都可以宽泛的认为是ModelServing的一部分。但相对于开源一些ModelServing工具来说我们还是有很多不同，大家可以简单对比一下。 Yatai https://www.bilibili.com/video/BV1J34y1e7Ys?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=f58d916e-393c-4423-8418-423ce4267b66&amp;share_source=GENERIC&amp;share_tag=s_i&amp;timestamp=1651273613&amp;unique_k=tE6zzq4 首先是我们的老朋友管锡鹏大佬目前在一个开源创业团队做的工作： bentoml下面有两个子项目：BentoML，Yatai BentoML可以通过简单的方法、注解定义，将模型的推理行为对外暴露成RESTFull的接口，并且可以自动攒Batch， 然后和其它基础库封装成一个镜像制品，称之为Bento。 Yatai提供了简单的UI控制台，将所有模型、Bento制品管理起来，并且可以选择对应版本部署到k8s集群上，并提供对应的日志、监控、跟踪等运维工具。PS：Yatai的界面、功能和MCD如出一辙。 KServe KServe之前叫KFServing，是Kubeflow生态中的一部分，现在独立项目开发。 KServe利用的开源技术栈比较多，比如Knative+Istio，之前比较重，现在已经变成可选。 KServe利用Knative实现了模型服务的自动扩缩容，实现了Serverless的能力。 KServer为了解决多模型的联动的问题，提了一个新的概念：ModelMesh Core工具链对比如果抛开具体的模型和业务逻辑，Core目前和ModelServing相关的部分组件： MegSDK/MegFlow，组装模型PPL，并对外暴露最近本的C/gRPC接口。 Laserd/Demod，负责任务调度，中间件封装，平台接入。 Saver，负责算法服务编排部署。 Longinus，负责全局流式任务调度。 相比于开源社区的ModelServing，Core工具链可能未覆盖的地方： 底层的平台未迁到k8s底座上，不太方便使用开源工具。 之前一直没有明确的模型、算法对应的registry，不方便做多版本的管理，目前打算放到AADC。 对模型的可解释性，算法服务的可观测性集成的工具链不多，运维平台包含了一部分功能。 模型、算法上线的流程比较简单，没有类似模型热加载、灰度上线、自动扩缩容等功能。 但Core工具链也有独特的地方： 因为MegEngine的存在，不需关注差异化的训练框架，反而在不同硬件平台上做了抽象。 在算法运行时上进行优化，适合多模型PPL组装和高性能计算。 上层流式任务调度比较完善，适合处理视频流或者消息流。 Model Serving参考链接 Seldon Core: Blazing Fast, Industry-Ready ML Machine Learning Model Serving Overview (Seldon Core, KFServing, BentoML, MLFlow) Paddle Serving 这个应该是旷视MegEngine生态下，ModelServing部分最直接的竞品。 旷视的MLOps？前面的资料里谈到的MLOps大部分都是针对通用的机器学习模型，相对于旷视这种深耕在计算机视觉领域，并且有很多独特业务场景，对软硬件要求都比较高的深度学习模型，很难有现成通用的MLOps解决方案可以参考。之前我以为将Data++、Brian++、Core串联起来，就可以认为是个MLOps流程。但从目前的模型发版、算法集成来看，还是有很多手动操作的地方，也需要工程化开发投入很多精力，并不是一个自动化的流程。如果创建一个大一统的MLOps平台，应该也是吃力不讨好的事情，它肯定会破坏现在各角色的工作流程，也很难做到灵活扩展。所以旷视的MLOps大概率可以走规范流，通过让不同系统留足接入空间，利用自动化工具打通各系统交接面，解决在面临复杂背景下快速交付模型和算法的问题。 复杂背景 模型耦合：相比互联网场景下，一个大模型或者几个模型就能拼装成预测服务；旷视最经典的人脸算法也是多达近十个模型组合而成，并且模型的输入输出深度绑定，数据传输效率要求较高。这些模型还是由不同R贡献，这就导致从数据、模型、代码的MLOps流程并不是简单的线性模式，有着复杂的耦合关系。目前SDK组的同学承担了很多关于PPL组装的工作，虽然也做了通过规范定义、简单配置、模型外挂的工作来降低模型的耦合性，使模型替换更顺畅，但类似bentoctl这种命令行工具或者UI界面，可以在真实环境自动化更换模型、部署算法服务、验证测试集的工具也可以考虑。 策略定制：另外一个旷视算法比较大的特色就是，模型的精度固然重要，但面对实际场景或者长尾场景，R更希望通过灵活的策略代码解决问题，这也是算法仓、检索策略仓、聚档策略仓出现的原因。之前的方案是R用Python将这个策略实现一遍，验证完将代码甩过来，Engineers再用C/GO实现一遍，然后频繁往复的对策略对分，有时候并不是策略对不上，可能就是因为语言特性、分布式环境就会有差异。这种场景下，R和Engineers以model为边界的界限就不太适用了，本质上大家都要对model+code的质量负责，而limbo/megflow就是为了解决这个问题。此时和BentoML类似，limbo/megflow提供了搭建模型inference和构建策略PPL的基础工具，R通过直接交付镜像来保证model+code的质量，而Engineers则更多关注硬件平台抽象、数据接入、任务调度、中间件抽象等分布式相关的内容。但这也面临一个问题，是暴露给R的概念越多越好吗？消息队列是抽象一层再暴露吗？如果暴露的太多，是不是Research的心智负担越重？另外开发完一个算法怎么快速部署、验证是恒久的问题，版本管理、打包和授权、可观测和监控怎么办？一个好的PaaS平台不仅要提供合理抽象，还要有完善的工具链来吸引开发者，这一点，公司内的MCD比较成功。但MegFlow+AADC面临的问题更复杂一些，不仅要解决算法运行时的效率和灵活性问题，还要解决算法开发、部署、打包、授权等问题，相信会越来越好。 角色繁多：MLOps的流程里一般只定义了三类角色，Data Engineers，Data Scientists，ML Engineers，但因为旷视交付的产品一般是软硬结合，限定特定领域的业务产品，所以一个高精度模型/算法真实到达客户现场经手的角色可能更多，包括：框架开发人员、业务开发人员、IPU测试，发版人员，交付人员等。在这种情况下，衡量模型/算法的生命周期更加困难，每个人了解到信息都是片面的，全靠PM的口头承诺或者晨光大佬的一篇wiki来保证。另外，这样容易产生两个问题：一是上游对结果无感知：比如R发了个模型发版邮件就结束了，这个模型被集成在什么megsdk版本？什么时候给到业务用？部署了多少个现场？模型运行效果如何？另一个问题是下游对版本很被动：比如对交付同学，可以查询到现在R正在酝酿发版的有哪些吗？Core当前集成的版本是哪个？有哪些检测模型效果更好，我可以无缝换着试试？当然这两个问题也有可能是我YY的，但总得来说如何有效的衡量模型和算法的Efficiency和Transparency是无论哪种MLOps都要考虑的问题。 环境割裂：相比互联网场景下，区分开发测试、线上生产的环境，或者全托管到云厂商的环境，旷视模型生成、部署的环境我认为是相当割裂的。数据的管理、模型训练在公司内相对封闭的Brain++，模型的工程化、集成测试是在公司内裸机器上，最终部署的环境又是客户自己的私有化集群。客户侧私有化环境是和产品绑定的，公司内两个独立的环境也确实能保护数据、模型的安全，但割裂的训练、工程化和推理环境也确实给MLOps的流程带来挑战。 首先是资源相互访问受限，先不提工程测试环境不像kubebrain一样统一资源管理和调度，两者底层计算、存储资源也无法相互融合，限制了整个公司的资源利用率。这一部分，恩哥之前有过一个构想，即使资源的不统一，技术栈上也可以尽量接近。当然，这一部分可能和MLOps关系不太大，应该是底层infra团队可能需要考虑的事情。但在MLOps这个层面，两个环境的数据、模型、代码相互访问受限，也会导致类似下模型/数据集要登入Brian++；开发limbo在brain++，测试limbo则需要在工程化环境；Brain++上部署不起来Core等问题。 然后是系统边疆感较强，缺少跨系统的CI/CD。因为上诉资源访问受限，再加上部分、角色的束缚，大家更倾向于在各个系统内部建设自动化部署、测试、版本管理的工具链，尽量避免系统间的联动。 最后则是很难形成闭环逻辑，如果说公司内部的训练和工程化通过很hack的手段总是可以互通，客户私有化的环境则很难使MLOps流程形成闭环，让大家忽略模型性能和效果的监控。一方面因为用户数据安全的要求，数据回流很困难；另一方面，模型和算法的模型效果取决于用户的行为，但CBG/EBG并不是2C面向大量用户行为的产品，用户反馈的误报、漏报数量不多，参考意义有限。 关于这一部分内容比较啰嗦，也比较偏主观，可能也不太正确，如果你耐心看完，给你点个赞。而且旷视在算法落地面临的挑战可能远不止这些，大家有关于整个流程不够自动化、不够方便易用的点都可以讨论，也为未来设计MLOps流程的同学多参考。 IPU在做啥？目前从我了解到内容，IPU关于MLOps流程的建设主要集中在两个平台：AADC、AI-PaaS AADC衔接了公司内的模型训练环境和算法工程化环境，产出是符合规范、可被部署的算法包。 AI-PaaS衔接了公司内的算法工程化环境和实际部署环境，负责模型、算法的部署以及后续监控、可观测性。 我只是简单介绍一下，如果有什么遗漏或者错误的地方，可以由对应的研发或者产品再补充一下。 @liujiashuo , @yangkai02 AADC(Algo Application Development Center) 用Gitops管理算法的技术spec信息：algo.yaml, project.json, e2etest.json等。 集成CI/CD的工具，来减少算法构建、授权、测试、发布的手动操作： MegFlow Pack CI: 协助算法开发者将model+code组装成最基本算法制品：image 或者 so，并对外保留规范化的接口：glider.proto/megflow.h Auth &amp; Encrpt CI: 完成基础制品的授权和加密工作。 Test CI: 对接QA的测试平台，触发算法仓基础单元测试或者e2e测试。 Export CI: 发布完备的算法包，无需交付自行手动打包。 公司内算法工程化开发、测试集群统一管理 指定集群依托AI-PaaS部署算法，用于开发验证。 集群资源监控，闲时资源利用，最大化利用集群资源。 公司内算法商城中心 已发布算法所有版本管理，历史追踪。 算法交付审计，统计面向不同BG/项目的算法交付情况。 参考链接： https://codimd.mcd.megvii-inc.com/z4E0e0x9QMm4DIp_empdMQ AI-PaaS 现场算法仓库中心 算法包的上架、授权和激活相关操作。 云-边计算资源管理，算法下发 流式任务创建和调度 算法产生的结构化数据汇聚和分发 参考链接： CEP-51: AI-PaaS 全流程？如果是将MLOps的全流程Run起来，肯定只有IPU的两个平台是不够的。最近翻wiki，也看到上下游部门在做一些事情，可以简单参考一下： AIS 这一部分，我也觉得比较绕，去年我理解的AIS是Brain++的单独商业版本，但目前好像分了三个版本：AIS公有版，AIS内部版，AIS-Lite？ 其中AIS对内版的算法量产模块，应该是将R算法量产的工具链集成到了AIS内部，然后面向AIT(AI训练师)这个角色，协助他们快速生产和模型。 AIS的其实覆盖了从数据收集、快速标注、自动训练、模型管理、模型部署整个流程的，但它目前ModelServing这一块应该只是针对单个模型的，和大部分MLOps的开源实现很像。而交付给CBG/EBG的算法，大部分都是以PPL+策略代码为主的算法，所以仍需要AADC+AI-PaaS。 算法量产和AIS的核心目标：KR1：完成CBG/EBG/大项目部等BG的主线算法生产标准化，使用AIS完成模型或PPL生产，覆盖率达到50%以上，AIT团队能够完成50%主线业务的发版和维护承接工作。 参考链接： 2022 算法量产 OKR 2022Q1 QBR 算法量产.pptx R和AIS合作研发流程 ADS(Auto Deploy Service) Engine组为了解决不同硬件平台算子的差异，提供给R协助将模型针对硬件选型进行转换的服务。 将模型转换后，需要配合MMP+MegEngine-Lite才能在硬件平台上运行，目前看MegFlow底层应该是依赖了这两个基础库，完成了在MC40芯片上嵌入式算法仓的实验工作。 参考链接： ADS 设计文档 MDP(Megvii Delivery Platform) 这个可能和MLOps本身没有多大关系，但如果我们希望将上述这些系统都能部署在k8s底座上，包括私有化版本的AIS，AI-PaaS，甚至悟空这样的业务产品，则需要一个解决方案交付流程。 MDP是参照阿里的ADP，根据旷视特色自己设计的一套云原生解决方案交付流程。 综合上面所有的系统，我们其实可以大概组装出旷视在建设的MLOps流程： 这个也是基于xxr的图，自己脑补的，有什么问题都可以指正。另外这些系统可能和恩哥都有点关系，有啥问题也可以多和恩哥聊，抱紧恩哥大腿。将这些系统组合起来，可以发现，如果列举的功能模块都比较完善的话，有没有可能达到一个我们理想的MLOps流程： 对一个大致料了解深度学习是什么，会一点Python的同学，姑且我们也称为AI训练师。在面临一个特定的算法问题时：- 他不需要了解业界最好的模型结构是什么？ -&gt; AIS/算法量产/snapx- 他不需要了解最终跑的硬件平台是什么？ -&gt; ADS/MMP- 他不需要了解怎么搭建高性能的InferenceServer？ -&gt; MegFlow- 他不需要了解保护代码和模型，怎么打包？ -&gt; AADC- 他不需要了解视频流怎么接入、任务调度、扩缩容、k8s？ -&gt; AI-PaaS 他可以不用写任何胶水代码，不用自己搭CI/CD，只需要在上诉四个系统：AIS-&gt;ADS-&gt;AADC-&gt;AI-PaaS的UI界面上点来点去，就可以一个人(或者加一个交付) 将一个高效的、经过验证的、可产品化的模型/算法部署到业务侧。在整个过程中，不需要高级研究员、框架开发、工程化开发、QA等同学的介入，最大程度地达到自动化流程。 MLOps-Sig前面提到，走规范流的MLOps并不是强调建立一个统一大平台入口，将所有关于数据集、模型、算法、部署的管理都放进去，而是更注重组织间的规范合作，业务流程，自动化水平。这显然靠单个平台的开发者推广是很难的，肯定是希望更多的同学尽量参与，不仅是研发，包括PM、测试等同学。这样大家对全景有个概念，后面开发相关工具的时候就可以有参考，慢慢地靠拢到一个流程。那怎么样让大家在一个地方交流呢？最近，罗少和恩哥应该会组织一些sig小组来让更多感兴趣的同学参与到类似MLOps，DevOps，DataOps的讨论当中。目前Sigs已经成为开源社区管理特定主题的方法，详细可以参考k8s-sigs。虽然我没做过啥开源社区贡献，比较low，但是如果后续有mlops-sig开展起来，我也想提供一些建议： 用Git管理文档：sig里面比较重要的就是管理大家的共识，包括：讨论主题、Feature&amp;Roadmap、架构图、日常同步章程、术语和规范、主席和成员等等，但不适宜放一些开发记录、bug讨论等内容。用Git管理则可以记录历史变更，提倡每个人都可以进行讨论和更改架构。 上下游的边界：sig小组覆盖完整上下游部门肯定是大家希望见到的，但无论怎样，了解上下游部门在做什么都是必要的。一方面，定义清楚各系统的边界面，共同维护数据规范，比如：模型打包格式、Megflow算法仓specs、算法包打包格式、任务创建格式、算法事件格式等，可以让开发的系统不耦合在一起，也不易出现扒接口的情况。另一方面，了解上下游实现的细节，多和其它部门同学聊天，多翻其它部门wiki，可以让大家对整体架构有更清晰的认识。其实，画上面那个图的时候，我也是比较虚的，只是描述了大致的功能流程；如果后面sig小组成立，可以细的了解上下游部门的实现，绘制更完整的模块架构图。 UI界面易接受：说实在的，目前应用比较广的两个平台性产品：Devops 和 MCD，在界面易用性其实都很不错，主要是因为它们的开发者天伟和锡鹏都来自豆瓣，对前端全栈开发都比较熟。平台开发后，推广使用阶段一般都可以提供三种方式：ctl工具，api接口文档，Dashboard。而Dashboard相比较而言，更容易体现一个用户的使用流程，完成用户故事；也能吸引大家随便点点，反馈更多问题。这也是core-ui虽然很简单，也吸引很多交付使用的原因。所以这也就要求PM花时间在原型图设计，研发在前端界面上求自己或者求他人。 云原生与Infra：其实MLOps流程和云原生并没有直接的联系，即使是在k8s流行之前，传统的机器学习也可以走MLOps流程。但云原生相关的技术大大减少重复造轮子的工作量，也能统一资源管理，减少资源浪费。目前看好像只有AI-PaaS还不能完全部署在k8s底座上面，后续可以考虑。另外，平台开发中可能用到的：pipeline、GPU虚拟化、边端集群管理、流量管理、Serverless、容器调度，都可以联系Infra团队来提供对应的能力，而上层平台则更foucus在抽象的合理性、功能的易用性。 关注开源社区：前面提到，无论是大的云厂商，还是一些创业公司都在做MLOps。关注一些开源项目，一方面可以了解一些新的技术和概念，扩充自己的知识面，把一些优先的想法引入到mlops-sig中；另一方面，因为旷视是深耕在视觉领域，业务大部分也是2B，所以如果对外向技术相关的人员解释我们的业务流更困难一些，但如果用一些开源的概念做类比，就比较顺畅一些，比较大家本质解决的问题是类似的。 终好了！两篇关于MLOps的介绍就到此结束了。文字表达上可能比较琐碎，但也总归融入了一些我的想法。 无论后面大家是做MLOps还是谈论MLOps，如果这两篇文章能帮助到大家，就万分荣幸了！谢谢大家！","link":"/2022/05/20/mlops/"},{"title":"排序算法总结","text":"比较排序选择排序(Selection Sort)思路： 每次选择最小的元素与第i个元素进行交换特点： 运行时间与输入无关，即使输入数据主键相同或有序，时间仍和最差相同，时间复杂度为 $N^2$ 数据移动最少，仅需要$N$次交换 在第i次，会进行1次exchange和 $N-i-1$ 次比较，总的比较次数为$N(N-1)/2$次 该算法为不稳定算法，因为有可能将 代码： 1234567891011public static void sort(int[] arr) { int n = arr.length; for (int i = 0; i &lt; n; i++) { int min = i; //从第i+1个开始寻找最小值 for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[min]) min = j; } SortUtils.exchane(arr, i, min); }} 插入排序(Insertion Sort)思路 将第i个元素插入到前面有序元素中合适的位置特点 最好情况下，即已经有序，则需要$N-1$次比较，$N$次移动 最差情况下，即完全逆序，需要$N^2$次比较和$N^2$次交换 平均情况下，需要$1/4N^2$次比较和$1/4N^2$次交换 交换次数和倒置数相同，需要就比较次数大于倒置数量，小于等于倒置的数量加上数组的大小再减一 倒置：数组中两个顺序颠倒的元素(可重复计数) 代码 12345678public static void sort(int[] arr) { int n = arr.length; for (int i = 1; i &lt; n; i++) { //从i-1个开始交换，直至到正确的位置 for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j + 1] &lt; arr[j]; j--) SortUtils.exchane(arr, j + 1, j); }} 折半查找插入排序（BinaryInsertionSort)思路在查找第i个元素在前面有序元素的位置时，采用二分查找的策略。特点： 最差情况下，也是需要$N^2$的时间复杂度。 最好情况下，需要$O(nlgn)$的时间复杂度。 代码 1234567891011121314151617181920212223242526public static void sort(int[] arr) { int n = arr.length; for (int i = 1; i &lt; n; i++) { int key = arr[i]; //查询需要插入的位置 int index = binarySearch(arr, 0, i - 1, key); //移动数据 for (int j = i - 1; j &gt;= index; j--) arr[j + 1] = arr[j]; arr[index] = key; }}private static int binarySearch(int[] arr, int i, int j, int key) { int low = i, high = j, mid; while (low &lt;= high) { mid = low + (high - low) / 2; if (arr[mid] == key) { return mid; } else if (arr[mid] &lt; key) { low = mid + 1; } else { high = mid - 1; } } return low;} 希尔排序(Shell Sort)思路 选取一个序列作为步长，然后通过大步长排序将元素移动到较远的地方（原始插入排序为一步步移动），从而使数组局部有序，最终再利用插入排序进行全局排序。特点 算法性能也取决于步长数组的选取 在最坏的情况下，算法的复杂度和$N^{3/2}$ 代码 1234567891011121314151617public static void sort(int[] arr) { int n = arr.length; int step = n / 2; //不断缩小step直至为1 while (step &gt;= 1) { //对每一组进行排序，一共step组 for (int i = 0; i &lt; step; i++) { //对每一组从第二个开始插入排序 for (int j = i + step; j &lt; n; j += step) { //一直交换到合适的位置 for (int k = j - step; k &gt;= 0 &amp;&amp; arr[k + step] &lt; arr[k]; k -= step) SortUtils.exchange(arr, k + step, k); } } step = step / 2; } } 冒泡排序思路每一次冒泡过程两两比较，如果发生逆序，则进行交换。总共需要n-1次冒泡，地k次冒泡需要比较n-k次。特点 时间复杂度为$O(N^2)$，空间复杂度为$O(1)$ 可以使用一个标志位，如果没有产生交换，则直接返回。 代码 1234567891011121314151617public static void sort(int[] arr) { int n = arr.length; //冒泡n-1次 for (int i = 0; i &lt; n - 1; i++) { //改进，如果当前次已经没有冒泡，则直接返回 boolean flag = true; //每次冒出一个最大值到最后边 for (int j = 0; j &lt; n - i - 1; j++) if (arr[j] &gt; arr[j + 1]) { //交换相邻位置的 SortUtils.exchange(arr, j, j + 1); flag = false; } if (flag) return; } } 快速排序思路 选取一个切分元素，将原始元素按照此标准进行切分为两个子数组，分别对子数组进行排序。快速排序和归并排序区别：归并排序是在递归后对数组进行操作，而快速排序则在递归钱对数组进行操作。简单的切分 选取切分元key，索引i，j分别为序列开始，索引j不断后移，当遇到a[j]&lt;=key时，则交换a[j]和a[i+1]，最后交换a[i]和key。这样索引i的左侧都为&lt;=key，右侧都为&gt;key。![Alt text](/images/Sort Algorithms Summary/1489046415296.png) 12345678910111213private static int simplePartition(int[] arr, int start, int end) { //默认选取第一个元素为切分元 int key = arr[start]; int i = start; //j后移 for (int j = start + 1; j &lt;= end; j++) { //遇到小于切分元的key，则交换 if (arr[j] &lt;= key) SortUtils.exchange(arr, ++i, j); } SortUtils.exchange(arr, i, start); return i;} 双工切分 选定a[lo]作为切分元素，使用指针i从左向右扫描比切分元素大的元素，指针j从右向左扫描比切分元素小的元素，交换两个元素的位置，重复上述过程，直至i和j相等，最后将a[lo]和a[j]交换，并返回j的索引。这种方法比上述方法交换次数较少。![Alt text](/images/Sort Algorithms Summary/1489050265957.png) 1234567891011121314151617181920private static int twoWayPartition(int[] arr, int start, int end) { //默认选择第一个元素为切分元 int key = arr[start]; int i = start + 1, j = end; while (i &lt;= j) { //向右寻找大的元素 while (i &lt;= j &amp;&amp; arr[i] &lt;= key) ++i; //向左寻找小的元素 while (i &lt;= j &amp;&amp; arr[j] &gt;= key) --j; //交换元素 if (i &lt; j) { SortUtils.exchange(arr, i, j); ++i; --j; } } //将切分元移到中间 SortUtils.exchange(arr, start, j); return j;} 半双工切分 与上述类似，但每次扫描完一边时就赋值数据，不需要交换数据。![Alt text](/images/Sort Algorithms Summary/1489051255182.png) 12345678910111213141516private static int oneWayPartition(int[] arr, int start, int end) { int key = arr[start]; int i = start, j = end; while (i &lt; j) { //向左寻找最小元素 while (i &lt; j &amp;&amp; arr[j] &gt;= key) j--; //覆盖元素 if (i &lt; j) arr[i++] = arr[j]; //向右寻找最大元素 while (i &lt; j &amp;&amp; arr[i] &lt;= key) i++; //覆盖元素 if (i &lt; j) arr[j--] = arr[i]; } arr[j] = key; return j;} 特点 将长度为Ｎ的无重复数组进行排序，快速排序平均需要～$NlnN$此比较和$1/6NlnN$次数据交换。 快速排序最多需要约为$N^2/2$次比较，此时就退化为冒泡排序。 优化 将小数组切换到插入排序 三取样排序，选取三个样本，基本为a[0],a[mid],a[high]三个，并选取中间数作为切分元素。 随机划分元，将最右边的元素与数组的随机一个元素进行交换，防止运行时间不依赖于输入序列的顺序。 1234567private static int randomPartition(int[] arr, int start, int end) { //选取随机元素索引 int randomIndex = new Random().nextInt(end - start + 1) + start; //交换 SortUtils.exchange(arr, start, randomIndex); return simplePartition(arr, start, end);} 使用算法导论上的算法，选取中位数。 代码 1234567891011121314 public static void sort(int[] arr) { sort(arr, 0, arr.length - 1); } private static void sort(int[] arr, int start, int end) { if (start &gt;= end) return; //划分数组// int index = simplePartition(arr, start, end);// int index = twoWayPartition(arr, start, end); int index = randomPartition(arr, start, end); //递归排序 sort(arr, start, index - 1); sort(arr, index + 1, end); } 归并排序自顶向下的归并排序思路 先将数组的两个子数组进行排序，然后进行归并。采用递归的思想，即不断递归左子数组，使其有序，再递归右子数组。特点 对于长度为$N$的任意数组，自顶向下的归并排序需要$1/2NlgN$（最好情况，左数组最大值比右数组最小值小）至$NlgN$（最坏情况，左数组和右数组交叉排序）次比较。证明思路：$C(2^n)=2C(2^{n-1})+ 2^n$==&gt;$C(2^n)/2^n=C(2^{n-1})/2^{n-1}+ 1$==&gt;$C(2^n)/2^n=C(2^0)/2^0+ n$==&gt;$C(N)=C(2^n)=n2^n=NlgN$ 对于长度为$N$的任意数组，自顶向下的归并排序需要$6NlgN$次比较，其中2N次复制，2N次移动回去，2N次比较时访问 代码 123456789101112131415161718192021222324252627282930313233public static void sort(int[] arr) { //创建一个临时数组 int[] temp = new int[arr.length]; sort(arr, 0, arr.length - 1, temp);}public static void sort(int[] arr, int start, int end, int[] temp) { if (start &gt;= end) return; int mid = start + (end - start) / 2; //左侧数组排序 sort(arr, start, mid, temp); //右侧数组排序 sort(arr, mid + 1, end, temp); //合并 merge(arr, start, mid, end, temp);}public static void merge(int[] arr, int start, int mid, int end, int[] temp) { int i = start, j = mid + 1, k = start; while (i &lt;= mid &amp;&amp; j &lt;= end) { if (arr[i] &lt;= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; } } while (i &lt;= mid) temp[k++] = arr[i++]; while (j &lt;= end) temp[k++] = arr[j++]; //复制回原数组 for (k = start; k &lt;= end; k++) { arr[k] = temp[k]; }} 自底向上的归并排序思路 先对微型数组归并，例如相邻的元素，在得到子数组。此时不需要采用递归。例如2==&gt;4==&gt;8==&gt;…的思路特点 自底向上的归并排序，其比较次数和访问数组次数都相同。但可以节省调用方法的时间 代码 123456789public static void downToUpSort(int[] arr) { int n = arr.length; int[] temp = new int[n]; //从最低的1开始，依次向上归并，每次步长为上次的2倍 for (int step = 1; step &lt; n; step += step) { for (int low = 0; low &lt; n - step; low += (step * 2)) merge(arr, low, low + step - 1, Math.min(low + step * 2 - 1, n - 1), temp); }} 优化 对小规模子数组采用插入排序 不将元素复制到辅助数组，采用角色互换的方法，减少一次复制的过程 堆排序相关概念 堆有序：当一颗二叉树的每个节点都大于等于它的子节点时，它被称为堆有序。 上浮：因为一个节点比其父节点大而产生无序状态，需交换该节点与父节点的位置。将新元素插入到数组末尾，然后增加堆的大小，再让该元素上浮到合适的位置。 下沉：因为一个节点比其子节点小而产生无序状态，需交换该节点与子节点中较大的位置。删除头部元素，再让数组末端元素放到顶端，减小堆的大小，让该元素下沉到合适位置。思路 将待排序元素构造成一个大顶堆，每次将堆顶元素和最后一个元素互换，然后再维护前n-1个元素形成大顶堆。特点 建堆的复杂度政委$O(n)$，每一次调整堆的复杂度为$O(lgN)$，因此总的复杂小于$O(n) + O(nlgn)$ 代码 123456789101112131415161718192021222324252627282930public static void sort(int[] arr) { int n = arr.length; //调整所有非叶子结点，形成最大堆 for (int i = n / 2 - 1; i &gt;= 0; i--) adjustHeap(arr, i, n - 1); for (int i = n - 1; i &gt;= 0; i--) { //取出堆顶元素到最后 SortUtils.exchange(arr, 0, i); //调整前面的元素仍称为最大堆 adjustHeap(arr, 0, i - 1); }}private static void adjustHeap(int[] arr, int start, int end) { int dad = start; int son = dad * 2 + 1; while (son &lt;= end) { //选中son中较大的结点 if (son &lt; end &amp;&amp; arr[son] &lt; arr[son + 1]) ++son; if (arr[dad] &lt; arr[son]) { //dad小于son则调整 SortUtils.exchange(arr, dad, son); dad = son; son = dad * 2 + 1; } else { //如果不需要调整，则直接退出 break; } }} 优化 多叉堆：对于完全三叉树，数组对应索引需要进行修改。父节点为k/3，子节点为3k-1,3k,3k+1 调整数组大小：不采用固定数组大小的模式，而是采用前面实现栈的方式，动态调整数组大小。 其它排序计数排序思路建立一个排序序列取值范围大小的数组C，然后根据C的下标，统计序列中每个元素出现的次数，然后累加每个元素之前元素的个数到该元素所在C中。最后根据C得到最后的排序序列。特点计数排序的限制（待排序序列的取值范围为k）：T(n) = (n + k)， 如果k &lt; n，T(n) = O(n); 否则，如果k &lt; nlgn，T(n) = O(nlgn); 否则，如果k &gt; n^2，T(n) = O(n^2); 代码 1234567891011121314151617public static void sort(int[] arr, int max) { int n = arr.length; int[] count = new int[max + 1]; for (int i = 0; i &lt;= max; i++) count[i] = 0; //计数 for (int i = 0; i &lt; n; i++) count[arr[i]]++; //累加 for (int i = 0; i &lt; max; i++) count[i + 1] += count[i]; //排序 int[] temp = new int[n]; for (int i = n - 1; i &gt;= 0; i--) { count[arr[i]]--; temp[count[arr[i]]] = arr[i]; } //复制回原数组 System.arraycopy(temp, 0, arr, 0, n);} 桶排序思路 将所有数的取值范围均匀划分成M个桶。 将N个元素分不到各个桶当中去。 对每个桶进行排序。 再依次将各个桶内元素取出，即为有序的序列。![Alt text](/images/Sort Algorithms Summary/1489110832115.png)特点时间复杂度为$O(N+C)$，$O(C)=O(M(N/M)log(N/M))=O(NlogN-NlogM)$，空间复杂度为$O(N+M)$，算法是稳定的，且与初始序列无关。 各类算法复杂度汇总![Alt text](/images/Sort Algorithms Summary/1489115690357.png)参考链接排序算法总结 面试算法之排序算法集锦","link":"/2017/03/14/Sort-Algorithms-Summary/"},{"title":"2022-job-codes","text":"二叉树 144. 二叉树的前序遍历 使用数组模拟stack时，记得从后面push，pop 94. 二叉树的中序遍历 处理顺序和访问顺序不一致，要先将左孩子全部压栈后才能开始处理节点。 for cur != nil || len(stack) != 0 { if cur != nil {stack = append(stack, cur); cur = cur.Left}} else { top = stack.pop(); res = append(res, res.Val); cur = top.Right} 145. 二叉树的后序遍历 要通过一个pre指针记录右子树是否已经处理完成，如果右子树为空||右子树==pre，才处理。 否则将自己重新入栈回去，等待下一次处理。 for cur != nil || len(stack) != 0 {if cur != nil {stack = append(strack,cur); cur = cur.Left}else {node := stack.pop(); if node.Right == nil || node.Right == pre { res = append(res); pre = node; cur = nil}else{ stack = append(stack, node); cur = cur.Right}}} 统一迭代法 通过加入空指针来控制要处理的节点后面，然后来达到对处理节点特殊逻辑的作用。 后序为例：stack.push(root); for !stack.empty(){node := stack.pop(); if node != nil{stack.push(left,right,node)}else{res = append(res, stack.pop().val())} 102. 二叉树的层序遍历 size要先读，直接使用append 226. 翻转二叉树 递归方法：本质就是使用前序遍历的方法，交换左右子树。 迭代方法：可以在前序、后序、层序三种选择一种，中间的append换成swap 101. 对称二叉树 递归方法：本质是两个前序遍历的配合：`if a == nil &amp;&amp; b == nil {return true}; if a== nil || b == nil {return false}; return a.Val == b.Val &amp;&amp; check(a.Left, b.Right) &amp;&amp; check(a.Right, b.Left) 迭代方法：使用前后队列来将需要比对的值，分别append到前和后。也可是使用栈，每次append一对。 104. 二叉树的最大深度 递归做法：return root== nil ? 0: 1 + math.MaxInt(hight(root.Left), hight(root.Right)) 迭代方法：层次遍历==BFS 111. 二叉树的最小深度 只有左右子树都不为空的时候，才返回1+min 110. 平衡二叉树 如果不平衡，直接返回-1 257. 二叉树所有路径 直接使用slice的[:2]避免root节点的特殊处理 112. 路径和 非叶子节点执行左右递归并取或 113. 路径和II 回溯法记录路径 106. 中序和后序构建二叉树 lib,lie, lpb,lpe := ib, index-1, pb, pb + (index-1-ib) rib,rie, rpb, rpe := index +1, ie, pe-1-(ie-index-1), pe-1 105. 前序和中序构建二叉树 lpb,lpe,lib,lie := pb+1, pb+1+(index-1-ib), ib, index -1 rpb,rpe,rib,rie := pe-(ie-index-1),pe,index+1, ie 617. 合并二叉树 700. 二叉树中的搜索 98. 验证二叉搜索树 递归要记录pre的值 非递归可以使用栈来模拟中序遍历，并记录前一个节点。 530. 二叉搜索树的最小绝对差 和上体基本一样，res := int(^zero&gt;&gt;1) 1530. 好叶子节点对的数量 利用后续遍历每个节点，返回每个节点到其叶子节点的距离，然后来判断路径和 236. 二叉树的最近公共祖先 左右子树都要遍历，将找到的节点一路返回。 left := lowestCommonAncestor(root.Left, p, q);right := lowestCommonAncestor(root.Right, p, q) ;if left != nil &amp;&amp; right != nil{return root};if left == nil &amp;&amp; right != nil{return right};if left != nil &amp;&amp; right == nil{return left} 701. 二叉搜索树中的插入操作 450. 删除二叉搜索树中的节点 删除的时候根据具体情况分类，如果左右节点都有，要将右孩子提上去，左孩子放到右树的最左侧。 669. 修剪二叉搜索树 if root.Val &lt; low {return trimBST(root.Right, low, high)}if root.Val &gt; high {return trimBST(root.Left, low, high)}root.Left = trimBST(root.Left, low, high)root.Right = trimBST(root.Right, low, high) 206. 反转链表 递归：newHead = reverse(head.next); head.next.next = head; head.next = nil; return newHead 非递归：虚拟头结点，遍历插入 108. 将有序数组转换为二叉搜索树 总结： 二叉树尽量使用递归，定义好递归的返回值。 公共祖先的问题可以返回一个vector来做。 · 动态规划 [63. 不同路径II] 初始化时记得横竖如果有障碍则没办法向后初始化。 for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; 递归表达式： if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; [343. 拆分整数] for (int j = 1; j &lt; i; j++) {curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));} [96. 不同的二叉搜索树] dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量 总结： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组","link":"/2022/01/02/2022-job-codes/"},{"title":"剑指Offer面试题总结","text":"面试3 二维数组中的查找二维数组中，从左到右，从上到下都是有序的，查找一个数是否存在。思路： 从右上角向左开始搜索，删除右侧的列，直到遇到比目标值小的数。 从右上角向下开始搜索，删除上方的行，直到遇到比目标值大的数。代码1234567891011121314151617boolean find (int[][] board,int rows,int columns,int key){ boolean found = false; int row = 0, column = columns - 1; while(row &lt; rows &amp;&amp; column &gt;= 0){ if(board[row][column] == key){ found = true; break; //右上角-&gt;左搜索，删除右侧列 }else if(board[row][column] &gt; key){ column --; }else{ //右上角-&gt;下搜索，删除上侧行 row ++; } } return found;} 面试8 旋转数组中的最小数把一个数组的最开始的若干个元素放到最后，成为一旋转数组。给定一个递增数组的旋转数组，求该数组中的最小值。思路：分别用index1表示前面子数组的第一个元素，index2表示后面子数组的最后一个元素。 如果是旋转数组，则arr[index1] &gt;= arr[index2]，否则直接返回。 如果arr[mid] &gt;= arr[index1]，则说明mid在前面的递增数组中，则可以将index1=mid。 如果arr[mid] &lt;= arr[index2]，则说明mid在后面的递增数组中，则可以将index2=mid。 考虑特殊情况：arr[mid]=arr[index1]=arr[index2]，则无法确定在哪个数组中；例如{1,0,1,1,1}的情况或者{1,1,1,0,1}的情况。 1234567891011121314151617181920212223242526272829int min(int[] rArr){ int n = rArr.length; int index1 = 0,index2 = n-1, mid = index1; while(rArr[index1] &gt;= rArr[index2]){ //如果差1，则找到结果 if(index2 - index1 == 1){ mid = index2; break; } mid = index1 + (index2 - index1)/2; //如果相等，则无法判断，只能顺序查找 if(rArr[mid] == rArr[index1] &amp;&amp; rArr[mid] == rArr[index2]){ int result = rArr[index1]; for(int i = index1 + 1; i &lt;= index2; i++){ if(rArr[i] &lt; result){ result = rArr[i] } } return result; //如果大于rArr[index1]，则说明在后面 }else if(rArr[mid] &gt;= rArr[index1]){ index1 = mid; //如果小于rArr[index2]，则说明在前面 }else if(rArr[mid] &lt;= rArr[index2]){ index2 = mid; } } return rArr[mid];} 面试10 二进制中1的个数求一个整数中1的个数思路1求32次，但是注意不能使用n&gt;&gt;1来判断循环是否结束（如果是负数，则符号位一直未1），而是利用flag&lt;&lt;1来判断。 123456789int bitCount(int n){ int count = 0; unsigned int flag = 1; while(flag){ if(n &amp; flag) count++; flag &lt;&lt;= 1; } return count;} 思路2当一个数n与n-1相与时，就将包括最后一位1的位全部之0，例如：1101 &amp; 1100 -&gt; 1100 ， 1010 &amp; 1001 -&gt; 1000，所以利用此种方案有多少1，则执行多少次循环。 12345678int bitCount(int n){ int count = 0; while(n){ count ++; n = n &amp; (n-1); } return count;} 拓展：两个整数m、n，m经过多少次位变换可以得到n：现将m、n异或，然后求异或值1的个数。利用&amp;1来判断是否是级数，右移来表示除以2 面试14 调整数组使所有奇数位于偶数前面输入一个整数数组，将所有的奇数位于前半部分，偶数位于后半部分。思路：利用快速排序中的partition的思路，进行一次交换O(n)的扫描，并交换。代码： 12345678910public void partitionArray(int[] array) { int start = -1; for (int i = 1; i &lt; array.length; i++) { if ((array[i] &amp; 1) != 0) { start++; exchange(array, start, i); } } exchange(array, start, 0);} 面试15 输入一个链表的倒数第k个节点给定一个单向链表，输出该链表的倒数第k个节点。思路： 如果空间复杂度允许，则可以使用栈，但肯定不是最优解。 维护两个指针，当第一个指针走到k时，第二个指针开始走。代码：123456789101112public ListNode lastK(ListNode head,int k){ ListNode p = head, q = null; int count = 0; while(p != null){ count++; if(count &gt;= k){ q = q == null ? head : q.next; } p = p.next; } return q;} 拓展： 求链表的中间节点，快指针每一次走两步，慢指针每一次走一步，则最后为中间节点。 求链表中是否存在一个环，则同样使用两个指针，一个快指针，一个慢指针。 面试22 判断一个序列是否为另一个序列的出栈序列输入两个整数序列，第一个序列为入栈的序列，判断第二个序列是否为第一个序列合法的出栈序列。思路 如果栈顶元素不为当前出栈元素，则顺序遍历输入序列，将当前元素之前的元素都入栈。如果无法找到该元素，则输出错我 如果栈顶元素为当前元素，或者栈为空，则直接出栈或执行下一个元素。代码1234567891011121314public boolean isStackOut(int[] in, int[] out) { if (in.length != out.length) return false; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int i = 0, j = 0; for (; j &lt; out.length; j++) { while (stack.isEmpty() || stack.peek() != out[j]) { if (i &gt;= in.length) return false; stack.push(in[i++]); } stack.pop(); continue; } return true; } 面试26 复杂链表的复制如果一个链表内不仅含有next指针，还有一个random指针，请完成这个链表的深拷贝。思路1利用一个Hash表存储&lt;N,N’&gt;对，最后再通过映射的方法来完成所有复制。时间复杂度为O(n)，空间复杂度为O(N)思路2 将新建结点放到原有结点的后面。![Alt text](/images/Offer Algorithms Summary/1496650732120.png) 根据前一个结点的random指针，对后一个结点的random指针进行修改。![Alt text](/images/Offer Algorithms Summary/1496650770141.png) 拆分原来的大链表，使其变为两个链表。![Alt text](/images/Offer Algorithms Summary/1496651008444.png)12345678910111213141516171819202122232425262728293031323334353637private void buildNodes(ListNode node){ if(node == null) return ; ListNode p = node; while(p != null){ ListNode q = new ListNode(p.val); q.next = p.next; p.next = q; p = q.next; }}private void copyRandomPointer(ListNode node){ if(node == null) return ; ListNode p = node; while(p != null){ if(p.random != null){ p.next.random = p.random.next; } p = p.next.next; }}private ListNode spiltList(ListNode node){ if(node == null) return null; ListNode p = node, q = node.next, newList = node.next; while( p != null){ p.next = q.next; p = p.next; q.next = p == null ? null : p.next; q = q.next; } return newList;}public ListNode copyList(ListNode node){ buildNodes(node); copyRandomPointer(node); return spiltList(node);} 面试28 字符的全排序给出一个字符串，打印出这个字符串所有的排序。思路 将第一个字符与后面的字符依次进行交换。 然后对后面的字符递归调用全排序。 将字符交换回来。12345678910111213141516171819202122public static void Permutation(String s) { char[] chars = s.toCharArray(); Permutation(chars, 0);}private static void Permutation(char[] chars, int begin) { if (begin == chars.length - 1 ) { System.out.println(Arrays.toString(chars)); } else { for (int i = begin ; i &lt; chars.length; i++) { exchagne(chars, begin, i); Permutation(chars, begin + 1); exchagne(chars, begin, i); } }}private static void exchagne(char[] chars, int i, int j) { char t = chars[i]; chars[i] = chars[j]; chars[j] = t;} 面试29 数组中此时超过一半的数字给定一个输入数组，其中一个数字出现次数超过了数组长度的一半，求出该数。思路1利用Partition的思路，对数组进行划分，不断缩小搜索长度。 如果返回index=n/2，则直接返回对应的数。 如果返回index&lt;n/2，则继续搜索后面的子数组。 如果返回index&gt;n/2，则继续搜索前面的子数组。 思路2因为其中一个数字出现次数比其他数字出现次数总和都多，因此遍历时可以保存上一个数字和出现次数。 如果和上一个次数相同，则加1。 如果和上一个次数不同，则减1。 如果次数等于0，则更换上一个数字，并将次数重新置为1。 12345678910111213141516public findHalfNumber(int[] arr){ int result = arr[0]; int count = 1; for(int i = 1; i &lt; arr.length; i++){ if(count == 0){ result = arr[i]; count = 1; }else if(arr[i] == result){ count++; }else{ count--; } } //check whether the result is right number return result;} 面试32 从1到n整数中1出现的次数输入一个整数n，求从1到n所有整数中1出现的次数。思路：递归求解，例如21345，可以分为两部分：11345,134621345来求解。在求解过程中，可以一次求解： 第一位为1的情况，即10000~19999中一的个数（如果第一位不为1）。 后面几位中为1的情况，可以固定一位，然后其他位任意去0~9 然后递归求解1~1245的情况。 1234567891011121314151617181920public int numberOf1(char[] chars, int begin) { if (begin &gt;= chars.length) return 0; int first = chars[begin] - '0'; if (begin == chars.length - 1) { if (first == 0) return 0; else return 1; } int result = 0; //第一位为1的所有数字 if (first &gt; 1) { result += (int) Math.pow(10, chars.length - begin - 1); } else if (first == 1) { result += Integer.valueOf(String.valueOf(chars, begin + 1, chars.length - begin - 1)) + 1; } //1346~21345中，除了第一位为1的其他为为1的所有数字,固定某一位为1，其他为取值0~9 result += first * (chars.length - begin - 1) * (int) Math.pow(10, chars.length - begin - 2); //递归求解1~1345的个数 result += numberOf1(chars, begin + 1); return result;} 面试33 第n个丑数定义一个数的因子只要2,3,5的数称为丑数，求第n个丑数。思路第n个丑数肯定是由前n-1个丑数生成的，用三个指针分别指向生成下一个丑数的位置，然后计算最小值来生成丑数，然后更新指针。 12345678910111213public int nthUglyNumber(int n){ int[] pointer = new int[3]{1,1,1}; int[] numbers = new int[n+1]; numbers[1] = 1; for(int i = 2; i &lt;= n; i++){ numbers[i] = Math.min(numbers[pointer[0]]*2,Math.min(numbers[pointer[1]*3],numbers[pointer[2]*5])); //更新指针 pointer[0] = numbers[i] == pointer[0]*2 ? pointer[0]+1:pointer[0]; pointer[1] = numbers[i] == pointer[1]*3 ? pointer[1]+1:pointer[1]; pointer[2] = numbers[i] == pointer[2]*5 ? pointer[2]+1 : pointer[2]; }} 面试37 两个链表的第一个公共结点两个链表，找到第一个公共结点思路遍历一遍先求出两个链表的长度，然后让长的链表先走，最后在一起走。 面试40 数组中只出现一次的数一个整形数组中除了两个数字之外，其它数字都出现了两次，找出这两个值出现一次的数字。思路 将数组中所有的数进行一次异或，获得的是两个只出现一次的数的异或。 找出这个异或结果的某一位的1取出来，作为划分数组的掩码，则两个数会分到不同的子数组。 然后对每个子数组进行一次异或，分别获得每个子数组的只出现一次的数。 123456789101112131415161718public int[] findNumbers(int[] arr){ int data = 0; for (int i = 0; i &lt; arr.length; i++) data ^= arr[i]; int mask = 1; while ((data &amp; mask) == 0) mask &lt;&lt;= 1; int num1 = 0, num2 = 0; for (int i = 0; i &lt; arr.length; i++) { if ((arr[i] &amp; mask) != 0) { num1 ^= arr[i]; } else { num2 ^= arr[i]; } } return new int[]{num1, num2};} 面试41 打印和为n的序列和给定n，打印序列1~n中和为n的所有连续子序列。思路 定义small和big用来存储序列最小值和序列最大值。 计算small到big的和，如果和为n，则打印序列。 如果和小于n则增大big。 如果和大于n则增大smll。 1234567891011121314public void printSequenceOfSum(int sum) { int small = 1, big = 2; while (small &lt;= (sum + 1) / 2) { int curSum = (small + big) * (big - small + 1) / 2; if (curSum == sum) { print(small, big); } if (curSum &gt;= sum) { small++; } else { big++; } }} 面试43 n个骰子和的概率分布给定n个筛子，求所有和的情况的概率分布 思路： 两个数组，第一个数组用于保存n-1个骰子时，各个和出现的次数；第二个数组用于保存n个骰子是，各个和出现的次数。 利用n-1,n-2,n-3,n-4,n-5,n-6来计算当前n的的次数。 交换两个数组，进行下一轮迭代。 123456789101112131415161718192021private static final int MAX_VALUE = 6;public void printProbability(int n) { if (n &lt;= 0) return; int[][] count = new int[2][n * MAX_VALUE + 1]; int flag = 0; for (int i = 1; i &lt;= MAX_VALUE; i++) count[flag][i] = 1; for (int i = 2; i &lt;= n; i++) { //小于i的都为0 for (int j = 0; j &lt; i; j++) count[1 - flag][j] = 0; for (int j = i; j &lt;= i * MAX_VALUE; j++) { for (int k = 1; k &lt;= j &amp;&amp; k &lt;= MAX_VALUE; k++) count[1 - flag][j] += count[flag][j - k]; } flag = 1 - flag; } double total = Math.pow(MAX_VALUE, n); for (int i = n; i &lt;= n * MAX_VALUE; i++) { System.out.printf(&quot;%d : % .6f\\n&quot;, i, count[flag][i] / total); }}","link":"/2017/06/13/Offer-Algorithms-Summary/"},{"title":"红黑树详解","text":"红黑树定义红黑树一种特殊的二叉查找树，在多种语言的多种数据结构中都有实现，查询效率较高。其特性是： 每个节点或者黑色，或者是红色。 根节点是黑色。 每个叶子结点（NIL）是黑色。 如果一个结点是红色，它的子节点必须是黑色。 从一个结点到该节点的子孙叶子结点的所有路径上包含相同数目的黑色结点。（确保没有一条路径会比其他路径长出两倍，接近于平衡二叉树。） ![Alt text](/images/Red-Black Tree/1490578618842.png) 红黑树的时间复杂度定理：一棵含有n个结点的红黑树的高度之多为$2log(n+1)$可以通过证明：高度为h的红黑树，他的包含的内节点的个数至少为$2^{h/2}-1$个。 红黑树的基本操作左旋对X进行左旋，意味着，将“X的右孩子”设为“X的父亲节点”；即，将 X变成了一个左节点。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。![Alt text](/images/Red-Black Tree/1491482439906.png) 《算法导论》伪代码： 12345678910111213141516LEFT-ROTATE(T, x) y ← right[x] // 前提：这里假设x的右孩子为y。下面开始正式操作 right[x] ← left[y] // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子 p[left[y]] ← x // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x p[y] ← p[x] // 将 “x的父亲” 设为 “y的父亲” if p[x] = nil[T] root[T] ← y // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点 else if x = left[p[x]] // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子” left[p[x]] ← y else // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子” right[p[x]] ← y left[y] ← x // 将 “x” 设为 “y的左孩子” p[x] ← y // 将 “x的父节点” 设为 “y” 右旋对X进行右旋，意味着，将“X的左孩子”设为“X的父亲节点”；即，将X变成了一个右节点。因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。![Alt text](/images/Red-Black Tree/1491485291292.png)《算法导论》伪代码： 1234567891011121314RIGHT-ROTATE(T, y) x ← left[y] // 前提：这里假设y的左孩子为x。下面开始正式操作 left[y] ← right[x] // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子 p[right[x]] ← y // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y p[x] ← p[y] // 将 “y的父亲” 设为 “x的父亲” if p[y] = nil[T] root[T] ← x // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点 else if y = right[p[y]] right[p[y]] ← x // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子” else left[p[y]] ← x // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子” right[x] ← y // 将 “y” 设为 “x的右孩子” p[y] ← x // 将 “y的父节点” 设为 “x” 红黑树的添加执行步骤： 将红黑树作为二叉查找树，将结点插入。 将插入结点的颜色置为”红色”。 通过旋转或者着色等操作，将二叉树重新变为一个红黑树。 如果被插入节点是根节点，则直接将该结点涂为黑色。 如果被插入节点的父节点是黑色，则不需要处理，认为红黑树。 如果被插入节点的父节点是红色，则需要根据叔叔结点的情况进行进一步处理。 对红色结点的调整 Case 现象说明 处理策略 Case 1 当前节点的父节点是红色，叔叔节点也是红色。 (01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点) Case 2 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子 (01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。 Case 3 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子 (01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。 ![Alt text](/images/Red-Black Tree/1491531856578.png) 12345678910111213141516171819202122232425262728293031323334353637383940//红黑树调整函数fixAfterInsertion()private void fixAfterInsertion(Entry&lt;K,V&gt; x) { x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) { if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) {//如果y为null，则视为BLACK setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 } else { if (x == rightOf(parentOf(x))) { x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 } setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 } } else { Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 } else { if (x == leftOf(parentOf(x))) { x = parentOf(x); // 情况5 rotateRight(x); // 情况5 } setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 } } } root.color = BLACK;} 红黑树的删除操作执行步骤： 将红黑树作为二叉查找树，将节点删除。 如果是叶节点，直接将叶节点删除。 如果删除结点只有一个儿子，将其子节点顶替其位置。 如果有两个非空子节点，则需要找出其后继节点。然后把后继节点替换到当前位置，并递归地删除后继节点。 通过“旋转和着色”来修正该树，使之重新成为一颗红黑树。 基本思想：删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。 删除修复操作分为四种情况(删除黑节点后)： 待删除的节点的兄弟节点是红色的节点。 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。 待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。 待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。 对黑色结点的调整 Case 现象说明 处理方案 Case 1 X是黑色结点，X的兄弟是红色结点，并且X的兄弟的子节点都是黑色节点 (01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。（无法从兄弟结点借调黑色结点，将兄弟结点上升，从兄弟结点的子节点借调，将其转换为Case 2,3,4） Case 2 X是黑色结点，X的兄弟是黑色结点，并且X的兄弟的子节点都是黑色节点。 (01) 将x的兄弟节点设为“红色”。(02) 设当前结点为X的父节点。（把兄弟结点变红后，有可能导致祖父结点失去平衡，因此需要回溯到父节点进行调整。） Case 3 X是黑色结点，X的兄弟是黑色结点，兄弟结点的左孩子是红色结点。 (01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。（中间状态，借用侄子结点的红色，变成黑色来平衡查找树。） Case 4 X是黑色结点，X的兄弟是黑色结点，兄弟结点的右孩子是红色结点。 (01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。（将兄弟结点的左黑色结点借调过来。） ![Alt text](/images/Red-Black Tree/1491572932688.png) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) { while (x != root &amp;&amp; colorOf(x) == BLACK) { if (x == leftOf(parentOf(x))) { Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 } if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) { setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 } else { if (colorOf(rightOf(sib)) == BLACK) { setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 } setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 } } else { // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 } if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) { setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 } else { if (colorOf(leftOf(sib)) == BLACK) { setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 } setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 } } } setColor(x, BLACK);} 删除操作总结：红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。 对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。 对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。 红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。 红黑树Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403package edu.tsinghua.zhangfei.datastructure;/** * Created by Fei Zhang on 2017/4/7. * Email:zhangfei614@126.com * - 每个节点或者黑色，或者是红色。 * - 根节点是黑色。 * - 每个叶子结点（NIL）是黑色。 * - 如果一个结点是红色，它的子节点必须是黑色。 * - 从一个结点到该节点的子孙叶子结点的所有路径上包含相同数目的黑色结点。（确保没有一条路径会比其他路径长出两倍，接近于平衡二叉树。） */public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; { static final boolean RED = true; static final boolean BLACK = false; private RBNode&lt;T&gt; root; static final class RBNode&lt;T extends Comparable&lt;T&gt;&gt; { T value; RBNode&lt;T&gt; left; RBNode&lt;T&gt; right; RBNode&lt;T&gt; parent; boolean color; RBNode(T value) { this.value = value; } RBNode(T value, boolean color, RBNode&lt;T&gt; parent, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right) { this.value = value; this.color = color; this.parent = parent; this.left = left; this.right = right; } boolean isRed() { return color; } } public RBTree() { this.root = null; } /** * 对X进行左旋，意味着，将“X的右孩子”设为“X的父亲节点”； * 即，将 X变成了一个左节点。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。 * * @param node */ private void leftRotate(RBNode&lt;T&gt; node) { if (node != null) { RBNode r = node.right; node.right = r.left; if (r.left != null) r.left.parent = node; r.parent = node.parent; if (node.parent == null) this.root = r; else if (node == node.parent.left) node.parent.left = r; else node.parent.right = r; r.left = node; node.parent = r; } } /** * 对X进行右旋，意味着，将“X的左孩子”设为“X的父亲节点”； * 即，将X变成了一个右节点。因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。 * * @param node */ private void rightRotate(RBNode&lt;T&gt; node) { if (node != null) { RBNode l = node.left; node.left = l.right; if (l.right != null) l.right.parent = node; l.parent = node.parent; if (node.parent == null) this.root = l; else if (node.parent.left == node) node.parent.left = l; else node.parent.right = l; l.right = node; node.parent = l; } } private RBNode find(T value){ int cmp; RBNode t = this.root; if (t == null) return null; do { cmp = value.compareTo((T) t.value); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t; } while (t != null); return null; } /** * 插入一个值： * 1. 将红黑树作为二叉查找树，将结点插入。 * 2. 将插入结点的颜色置为&quot;红色&quot;。 * 3. 通过旋转或者着色等操作，将二叉树重新变为一个红黑树。 * 如果有值，则返回引用；没有值则返回null * * @param value * @return */ public RBNode insert(T value) { int cmp; RBNode parent, t = this.root; //如果根为空，则直接插入。 if (t == null) { RBNode node = new RBNode(value); this.root = node; return null; } do { parent = t; cmp = value.compareTo((T) t.value); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t; } while (t != null); RBNode node = new RBNode(value, RED, parent, null, null); if (cmp &lt; 0) parent.left = node; else parent.right = node; fixAfterInsertion(node); return null; } /** * 插入值后的调整： * - 如果被插入节点是根节点，则直接将该结点涂为黑色。 * - 如果被插入节点的父节点是黑色，则不需要处理，认为红黑树。 * - 如果被插入节点的父节点是红色，则需要根据叔叔结点的情况进行进一步处理。 * | Case 1|当前节点的父节点是红色，叔叔节点也是红色。| (01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)| * | Case 2|当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子 | (01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。| * | Case 3|当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子|(01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。| * * @param node */ private void fixAfterInsertion(RBNode node) { node.color = RED; while (node != null &amp;&amp; node != root &amp;&amp; colorOf(parentOf(node))== RED) { if (parentOf(node) == leftOf(parentOf(parentOf(node)))) { RBNode uncle = rightOf(parentOf(parentOf(node))); //case 1 if (colorOf(uncle) == RED) { setColor(parentOf(node),BLACK); setColor(uncle,BLACK); setColor(parentOf(parentOf(node)),RED); node = parentOf(parentOf(node)); } else { //case 2 if (node == rightOf(parentOf(node))) { node = parentOf(node); leftRotate(node); } //case 3 setColor(parentOf(node),BLACK); setColor(parentOf(parentOf(node)),RED); rightRotate(parentOf(parentOf(node))); } } else { RBNode uncle = leftOf(parentOf(parentOf(node))); if (colorOf(uncle) == RED) { setColor(parentOf(node),BLACK); setColor(uncle,BLACK); setColor(parentOf(parentOf(node)),RED); node = parentOf(parentOf(node)); } else { if (node == leftOf(parentOf(node))) { node = parentOf(node); rightRotate(node); } setColor(parentOf(node),BLACK); setColor(parentOf(parentOf(node)),RED); leftRotate(parentOf(parentOf(node))); } } } root.color = BLACK; } /** * 删除一个值： * 1. 将红黑树作为二叉查找树，将节点删除。 * - 如果是叶节点，直接将叶节点删除。 * - 如果删除结点只有一个儿子，将其子节点顶替其位置。 * - 如果有两个非空子节点，则需要找出其后继节点。然后把后继节点替换到当前位置，并递归地删除后继节点。 * 2. 通过“旋转和着色”来修正该树，使之重新成为一颗红黑树。 * * @param value * @return */ public void delete(T value) { RBNode t = find(value); if (t == null) return; //如果是双非空子节点，找到后继，并替换 if (t.left != null &amp;&amp; t.right != null) { RBNode successor = successor(t); t.value = successor.value; t = successor; } RBNode replacement = t.left != null ? t.left : t.right; //如果是单非空子节点，则直接删除替换 if (replacement != null) { replacement.parent = t.parent; if (t.parent == null) { root = replacement; } else if (t == t.parent.left) { t.parent.left = replacement; } else { t.parent.right = replacement; } t.parent = t.left = t.right = null; //如果是双空结点 } else if (t.parent == null) { this.root = null; } else { if (t.color == BLACK) fixAfterDeletion(t); if (t.parent != null) { if (t == t.parent.left) t.parent.left = null; else if (t == t.parent.right) t.parent.right = null; t.parent = null; } } } /** * 寻找后继结点 * //在查找过程中，如果节点x右子树不为空，那么返回右子树的最小节点即可 * //如果节点x的右子树为空，那么后继节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子 * * @param node * @return */ private RBNode successor(RBNode node) { if (node == null) return null; if (node.right != null) { RBNode p = node.right; while (p.left != null) p = p.left; return p; } else { RBNode p = node.parent; while (p != null &amp;&amp; node == p.right) { node = p; p = p.parent; } return p; } } /** * 基本思路： * 删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。 * | Case 1| X是黑色结点，X的兄弟是红色结点，并且X的兄弟的子节点都是黑色节点|(01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。（无法从兄弟结点借调黑色结点，将兄弟结点上升，从兄弟结点的子节点借调，将其转换为Case 2,3,4）| * | Case 2| X是黑色结点，X的兄弟是黑色结点，并且X的兄弟的子节点都是黑色节点。| (01) 将x的兄弟节点设为“红色”。(02) 设当前结点为X的父节点。（把兄弟结点变红后，有可能导致祖父结点失去平衡，因此需要回溯到父节点进行调整。）| * | Case 3| X是黑色结点，X的兄弟是黑色结点，兄弟结点的左孩子是红色结点。|(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。（中间状态，借用侄子结点的红色，变成黑色来平衡查找树。）| * | Case 4| X是黑色结点，X的兄弟是黑色结点，兄弟结点的右孩子是红色结点。| (01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。（将兄弟结点的左黑色结点借调过来。）| * * @param node */ private void fixAfterDeletion(RBNode node) { while (node != root &amp;&amp; colorOf(node) == BLACK) { if (node == leftOf(parentOf(node))) { RBNode sib = rightOf(parentOf(node)); if(colorOf(sib) == RED){ setColor(sib,BLACK); setColor(parentOf(node),RED); leftRotate(parentOf(node)); sib = rightOf(parentOf(node)); } if(colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK){ setColor(sib,RED); node = parentOf(node); }else{ if(colorOf(rightOf(sib)) == BLACK){ setColor(leftOf(sib),BLACK); setColor(sib,RED); rightRotate(sib); sib = rightOf(parentOf(node)); } setColor(sib,colorOf(parentOf(node))); setColor(parentOf(node),BLACK); setColor(rightOf(sib),BLACK); leftRotate(parentOf(node)); node = root; } } else { RBNode sib = leftOf(parentOf(node)); if(colorOf(sib) == RED){ setColor(sib,BLACK); setColor(parentOf(node),RED); rightRotate(parentOf(node)); sib = leftOf(parentOf(node)); } if(colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK){ setColor(sib,RED); node = parentOf(node); }else{ if(colorOf(leftOf(sib)) == BLACK){ setColor(rightOf(sib),BLACK); setColor(sib,RED); leftRotate(sib); sib = leftOf(parentOf(node)); } setColor(sib,colorOf(parentOf(node))); setColor(parentOf(node),BLACK); setColor(leftOf(sib),BLACK); rightRotate(parentOf(node)); node = root; } } } } public void preOrder(){ preOrderHelper(this.root); System.out.println(); } private void preOrderHelper(RBNode node){ if(node == null) return; System.out.print(&quot;(&quot; + node.value.toString() + &quot;,&quot; + colorName(colorOf(node)) + &quot;)&quot;); preOrderHelper(node.left); preOrderHelper(node.right); } public void midOrder(){ midOrderHelper(this.root); System.out.println(); } private void midOrderHelper(RBNode node){ if(node == null) return; midOrderHelper(node.left); System.out.print(&quot;(&quot; + node.value.toString() + &quot;,&quot; + colorName(colorOf(node)) + &quot;)&quot;); midOrderHelper(node.right); } private static boolean colorOf(RBNode p) { return (p == null ? BLACK : p.color); } private static RBNode parentOf(RBNode p) { return (p == null ? null : p.parent); } private static void setColor(RBNode p, boolean c) { if (p != null) p.color = c; } private static RBNode leftOf(RBNode p) { return (p == null) ? null : p.left; } private static RBNode rightOf(RBNode p) { return (p == null) ? null : p.right; } private static String colorName(boolean color){ return color == RED ? &quot;RED&quot; : &quot;BLACK&quot;; } public static void main(String[] args){ Integer[] test = new Integer[]{1,2,3,4,5,6,7,8}; RBTree&lt;Integer&gt; rbTree = new RBTree&lt;Integer&gt;(); for(Integer integer: test) rbTree.insert(integer); rbTree.delete(4); rbTree.preOrder(); rbTree.midOrder(); }} 参考链接：红黑树深入剖析及Java实现史上最清晰的红黑树讲解（上）史上最清晰的红黑树讲解（下）红黑树(一)之 原理和算法详细介绍","link":"/2017/06/13/Red-Black-Tree/"},{"title":"Nvim配置趟坑","text":"nvim配置流水 参考learn-neovim-lua。 快捷键部分，因为Mac上没有Alt，在iterm2中设置左Option-&gt;Esc+。 将所有plugin注释掉，按需开启；将plugin拉取git仓库的方式从https改为git-ssh的方式；注释掉更改plugins.lura，自动更新代码。 安装nvim-tree插件： 注意将回车设置成打开文件；安装nerd-font显示各类图标；打开显示dotfile。 安装bufferline和lualine组件：多标签页打开。 安装telescopre组件：先brew安装reggrep,fd。 安装dashboard组件：自定义开始界面和功能。 安装treesiter组件：语法高亮，语法树选中，代码折叠等功能。 安装LSP等功能：同时安装npm等工具； 其他工具： indent-blankline:在上下文锻炼段落前加上指示。 123456789# intsall brew install neovim# copy config from learn-neovim-luagit clone git@github.com:zhangfei614/nvim-lua-guide.git ~/.config/nvim# install nd fontbrew tap homebrew/cask-fontsbrew install --cask font-hack-nerd-font 参考链接 Neovim 配置实战：从0到1打造自己的IDE ZhangFei’s Nvim","link":"/2022/06/14/nvim-config/"},{"title":"Mac装机配置","text":"Zsh相关配置 生成ssh-key: ssh-keygen -t ed25519，并运行ssh-agent,ssh-add 安装iterm2, vscode, brew, oh-my-zsh, tmux, autojump export TERM=xterm-256color,HOMEBREW_NO_AUTO_UPDATE=1 安装znap，znap-plugins(zsh-completions, zsh-autosuggestions) 参考链接：The Znap ZSH plugin-manager 更新.zshrc Go, k8s, Docker 相关安装 brew install go, kubectl, minikube brew install –casks docker set envs in .zshrc 其它工具安装 Clipy， 管理复制粘贴。 Magent，管理窗口。","link":"/2022/06/16/mac-setup/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","link":"/tags/DeepLearning/"},{"name":"PyTorch","slug":"PyTorch","link":"/tags/PyTorch/"},{"name":"Detection","slug":"Detection","link":"/tags/Detection/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"ModelServing","slug":"ModelServing","link":"/tags/ModelServing/"},{"name":"Megvii","slug":"Megvii","link":"/tags/Megvii/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"R-B Tree","slug":"R-B-Tree","link":"/tags/R-B-Tree/"},{"name":"nvim, tool, config","slug":"nvim-tool-config","link":"/tags/nvim-tool-config/"},{"name":"Mac, Tools","slug":"Mac-Tools","link":"/tags/Mac-Tools/"}],"categories":[{"name":"DeepLearning","slug":"DeepLearning","link":"/categories/DeepLearning/"},{"name":"MLOps","slug":"MLOps","link":"/categories/MLOps/"},{"name":"Job","slug":"Job","link":"/categories/Job/"},{"name":"Algorithms","slug":"Algorithms","link":"/categories/Algorithms/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"}]}